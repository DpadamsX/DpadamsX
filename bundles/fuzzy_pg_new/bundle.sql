/*bundle folder: fuzzy_pg_newBuild date:   2020-04-19T23:51:00ZDescription:  fThis script combines the following files into a single transaction:Build scripts:01_clean_slate.sql02_text_collection.sql   Coyote:Users:dpadams2:Resilio Sync:DPA:nautilus:tables:ascendco:text_collection.sql03_text_collection_item.sql   Coyote:Users:dpadams2:Resilio Sync:DPA:nautilus:tables:ascendco:text_collection_item.sql04_text_collection_v1_view.sql alias   Coyote:Users:dpadams2:Resilio Sync:DPA:nautilus:types_plus:text_collection_v1:text_collection_v1_view.sql05_insert_text_collection_v1.sql alias   Coyote:Users:dpadams2:Resilio Sync:DPA:nautilus:types_plus:text_collection_v1:insert_text_collection_v1.sql*/BEGIN;-- 01_clean_slate.sqlDROP VIEW IF EXISTS types_plus.text_collection_v1;DROP FUNCTION IF EXISTS types_plus.insert_text_collection_v1 (text[], boolean);DROP TABLE IF EXISTS ascendco.text_collection_item;DROP TABLE IF EXISTS ascendco.text_collection;-- 02_text_collection.sql-------------------------------------- Define text_collection table------------------------------------DROP TABLE IF EXISTS ascendco.text_collection CASCADE;CREATE TABLE IF NOT EXISTS ascendco.text_collection (	id                uuid         NOT NULL DEFAULT extensions.gen_random_uuid(),    collection_name   citext       NOT NULL DEFAULT '',    added_dts         timestamptz  NOT NULL DEFAULT NOW()::timestamptz,	facility_id       uuid         NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000'::uuid,    retain            boolean      NOT NULL DEFAULT false); -- Skip true rows when purging old data.ALTER TABLE ascendco.text_collection	ADD CONSTRAINT text_collection_pkey    PRIMARY KEY (id);ALTER TABLE ascendco.text_collection	SET UNLOGGED;/*This is a good place for a temoprary table, as the cleanup happens automatically when you drop the connection.For now, I want to keep the ability to spot-check the strings while I'm developing. Maybe I'll switch totemporary tables later. For now, I'm going with UNLOGGED as at least it clears out some overhead on INSERTand DELETE, one of the benefits of temporary tables.https://www.depesz.com/2011/01/03/waiting-for-9-1-unlogged-tables/https://blog.nukomeet.com/faster-inserts-how-to-increase-postgresql-write-performance-24d76bd56f75List all unlogged tables within the current database.SELECT relname FROM pg_class WHERE relpersistence = 'u';*/-------------------------------------- Build indexes-------------------------------------- If a name/label is included, it shoudl be unique.CREATE UNIQUE INDEX text_collection_nameidx	ON text_collection (collection_name)	WHERE (collection_name <> '');-------------------------------------- Add triggers-------------------------------------- Nope, this is pretty much a one-and-done table, don't care about tracking deletes, etc.-------------------------------------- Add GRANTS-------------------------------------- Not normal, jamming these in for my quick tests.GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection TO rds_super;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection TO user_reporting;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection TO user_iceberg;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection TO user_change_structure;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection TO user_sonar;-- 03_text_collection_item.sql-------------------------------------- Define text_collection_item table------------------------------------DROP TABLE IF EXISTS ascendco.text_collection_item;CREATE TABLE IF NOT EXISTS ascendco.text_collection_item (	collection_id    uuid        NOT NULL DEFAULT NULL,  -- Shared by all strings in the same collection.	text             citext      NOT NULL DEFAULT '');ALTER TABLE ascendco.text_collection_item	SET UNLOGGED;ALTER TABLE ascendco.text_collection_item	ADD CONSTRAINT text_collection_item_pkey    PRIMARY KEY (collection_id,text);ALTER TABLE ascendco.text_collection_item	ADD CONSTRAINT text_collection_item_parent_fkey	FOREIGN KEY (collection_id)	REFERENCES ascendco.text_collection (id)	ON DELETE CASCADE	ON UPDATE NO ACTION;ALTER TABLE ascendco.text_collection_item	OWNER TO user_change_structure;/*This is a good place for a temoprary table, as the cleanup happens automatically when you drop the connection.For now, I want to keep the ability to spot-check the strings while I'm developing. Maybe I'll switch totemporary tables later. For now, I'm going with UNLOGGED as at least it clears out some overhead on INSERTand DELETE, one of the benefits of temporary tables.https://www.depesz.com/2011/01/03/waiting-for-9-1-unlogged-tables/https://blog.nukomeet.com/faster-inserts-how-to-increase-postgresql-write-performance-24d76bd56f75List all unlogged tables within the current database.SELECT relname FROM pg_class WHERE relpersistence = 'u';*/-------------------------------------- Build indexes-------------------------------------- Magic GiST index for K-NN search.CREATE INDEX text_collection_item_text_ix_tgrm_gist	ON ascendco.text_collection_item	USING gist(text COLLATE pg_catalog.default extensions.gist_trgm_ops);-------------------------------------- Add triggers-------------------------------------- Nope, this is pretty much a one-and-done table, don't care about tracking deletes, etc.-------------------------------------- Add GRANTS-------------------------------------- Not normal, jamming these in for my quick tests.GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection_item TO rds_super;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection_item TO user_reporting;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection_item TO user_iceberg;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection_item TO user_change_structure;GRANT SELECT, INSERT, UPDATE, DELETE ON text_collection_item TO user_sonar;-- 04_text_collection_v1_view.sql alias-- Create a view onto text_collection formatted as text_collection_v1.-- If text_collection changes, you can update the view to handle the modification smoothly.-- Note: This view is automatically a custom type, with an array type to match. See types_plus.insert_text_collection_v1.DROP VIEW IF EXISTS types_plus.text_collection_v1 CASCADE;-- Careful!CREATE OR REPLACE VIEW types_plus.text_collection_v1 AS select id,        collection_name,        added_dts,        retain,        facility_id   from text_collection;ALTER TABLE types_plus.text_collection_v1    OWNER TO user_change_structure;-- 05_insert_text_collection_v1.sql alias-- Create a function to accept an array of rows formatted as text_collection_v1 for UPSERT into text_collection.DROP FUNCTION IF EXISTS types_plus.insert_text_collection_v1 (text[], boolean, citext);CREATE OR REPLACE FUNCTION types_plus.insert_text_collection_v1 (    data_in             text[],    mark_for_retention  boolean DEFAULT false,    collection_name_in  citext  DEFAULT '')RETURNS uuidAS $BODY$-- First, add the new collection and get back the new ID for use in the rest of the script.WITH new_collection AS (  INSERT INTO text_collection (       retain,       collection_name)VALUES (mark_for_retention,       collection_name_in)RETURNING id)-- Now, unpack the incoming array of strings, and insert each one into-- text_collectoin_item, along with the ID of the text_collection just created.INSERT INTO text_collection_item (       collection_id,       text)SELECT      new_collection.id,      rows_in.text FROM new_collection,      unnest(data_in) as rows_in -- Silently remove duplicates from the list. ON CONFLICT (collection_id, text) DO NOTHING -- RETURNING is a *very* cool Postgres extension to standard SQL. -- Earlier, we used it to get the new ID out of the CTE for reuse -- by the main query. Now, we're returning that ID to the client -- for whatever purpose they have.RETURNING collection_id;$BODY$LANGUAGE sql;ALTER FUNCTION types_plus.insert_text_collection_v1(text[], boolean, citext)	OWNER TO user_bender;COMMIT;