If (False)  // ===========================================	^method_name^		  // DESCRIPTION: Push data from a collection of ""^odt_type_name^"" objects to Nautilus.	  	  // The collection is prepared by	  ^collection_method_name^	  	  // Note: For details on the "^odt_type_name^" object format, see it's constructor:	  ^odt_constructor_name^	  	  // Add a type dependency declaration to the type's declaration method:	  ^odt_declaration_name^	ODTDependency_Declare("^odt_type_name^";^odt_hash_text^;"^method_name^";"Postgres push method for a collection of '^odt_type_name^' objects.")		  // Add the following lines to the appropriate compiler method:	C_BOOLEAN(^method_name^;$0)	C_OBJECT(^method_name^;$1)		  // CREATED BY: David Adams	  // DATE: ^created_on^	  // LAST MODIFIED: End if   // ============================================Code_Start (Current method name)C_BOOLEAN($0;$ran_okay)C_OBJECT($1;$connection_object)$connection_object:=$1  // Pass a good connection ID or you're toast.C_COLLECTION($data_collection)$data_collection:=^collection_method_name^ // Each item in the collection is expected and required to be of the ODT type '^odt_type_name^'.C_LONGINT($connection_id)C_LONGINT($items_count)C_TEXT($table_name_in_postgres_text)  // Exact table name in nautilus. If the table is renamed there, update the value here.C_TEXT($table_name_for_prefs_text)  // Table name when this method was created. If the table name changes in nautilus, leave this alone or update all existing prefs references.$connection_id:=$connection_object.connection_id$items_count:=$data_collection.length$table_name_in_postgres_text:="^pg_table_name^"$table_name_for_prefs_text:="^pg_table_name^"C_BOOLEAN($continue)$continue:=FalseIf ($connection_id>0)	$ran_okay:=True	$continue:=False		If ($items_count>=1)  // The collection is not empty.		$continue:=True			  // Test the type of the first item...just the first item. Could check all...could check none...going for a spot-check.		If (ODT_ObjectType_Disagrees ($data_collection[0];"^odt_type_name^"))			Code_Err ("";"Collection object tested is not of the expected ODT type: 'pg_connection'")			$continue:=False			$ran_okay:=False					End if 			End if 	End if If ($continue)		  //-------------------------------------------------------  // Prepare and push the data  //-------------------------------------------------------			If ($items_count=0)		$ran_okay:=True	Else 	^conid_sort_statement^				C_TEXT($cr)		C_TEXT($tab)		C_TEXT($sq)		^conid_variable_declaration^		$cr:=Char(Carriage return)		$tab:=Char(Tab)		$sq:=Char(Quote)			  //------------------------------------------------------------------------		  // Prepare the INSERT clause		//------------------------------------------------------------------------		C_TEXT($insert_text)		$insert_text:=""		$insert_text:=$insert_text+"BEGIN;"+$cr		$insert_text:=$insert_text+"INSERT INTO ^pg_table_name^ ("+$cr		^insert_block^		$insert_text:=$insert_text+"VALUES"+$cr			  // $values_text+$cr  goes in here for the push. The VALUES statements are built in the loop below.			  //------------------------------------------------------------------------		  // Prepare the ON CONFLICT clause		//------------------------------------------------------------------------		C_TEXT($on_conflict_text)		$on_conflict_text:=$on_conflict_text+$cr		$on_conflict_text:=$on_conflict_text+"ON CONFLICT(id) DO UPDATE SET "+$cr		^on_conflict_block^			  //------------------------------------------------------------------------		  // Set up the environment		//------------------------------------------------------------------------		C_LONGINT($maximum_push_bytes)		C_LONGINT($overhead_bytes)  // How many bytes are we using for the declarative bits?		C_OBJECT($insert_object)		$maximum_push_bytes:=Iam_GetPGMaximumPushKB *1024  // We want bytes to compare to the results from calling Length($values_text)		$overhead_bytes:=Length($insert_text)+Length($on_conflict_text)  // How many bytes are consumed by the declarative bits?		$insert_object:=PgQuery_New ($connection_object;"";"^method_name^")  // The same query object is used for each push in this method. The SQL payload gets reset for each push.			  //------------------------------------------------------------------------		  // Fold the data into values statements.		  //------------------------------------------------------------------------		C_BLOB($values_blob)  // Accumulate in a BLOB, crazy faster than accumulating in a text var.		SET BLOB SIZE($values_blob;0)		^data_file_id_assignment^		C_LONGINT($item_index)		c_object($data_object)		For each ($data_object;$data_collection)					$item_index:=$item_index+1// We need this to track our position in the loop.			^conid_tracking_statement^			  // Convert the current row to a properly escaped and formatted value row. We're doing multi-row inserts, to this is a ("parens","sort","of","deal",5)			C_TEXT($clause_text)			$clause_text:=""			^values_block^			C_LONGINT($push_data_size_bytes)			C_BOOLEAN($push_now)			$push_data_size_bytes:=BLOB size($values_blob)+Length($clause_text)+$overhead_bytes					Case of 				: ($item_index=$items_count)  // We've gone through all of the records.					$push_now:=True								: ($push_data_size_bytes>=$maximum_push_bytes)  // We've filled the buffer.					$push_now:=True								Else   // Keep on building the VALUES.					$push_now:=False			End case 					If ($push_now=False)				$clause_text:=$clause_text+","+$cr  // We now *know* that we're going to add another value (statement), so we also know that we need a comma. The last (value) does *not* have a comma.			End if 					TEXT TO BLOB($clause_text;$values_blob;UTF8 text without length;*)				  //------------------------------------------------------------------------		  // Push!		  //------------------------------------------------------------------------			If ($push_now)			  // We've filled our buffer (based on max KB from IAM) or reached the last record. Push! 							  // This doubles memory consumption briefly. I asked Rob about a command that accepts a BLOB instead of text.				  // He said "no" as it would require a text copy internally anyway, so it won't help. If memory is an issue,				  // write to disk instead of text or BLOB and then use Document to text to load the block in one go.				C_TEXT($values_text)  // The VALUES are built up in the loop below. When we've got all the records, or have filled our self-defined buffer, a push is sent.				$values_text:=BLOB to text($values_blob;UTF8 text without length)				SET BLOB SIZE($values_blob;0)  // Free up the RAM.							If (False)					SET TEXT TO PASTEBOARD($insert_text+$values_text+$on_conflict_text)				End if 							  // Jam the text right into the object...not calling PgQuery_SetSQLStatement here in case text is built (doubled) by for 4D for the parameter.				OB SET($insert_object;PgQuery_Statement_SQL;$insert_text+$values_text+$on_conflict_text)				$values_text:=""  // Clear this now! It frees up memory before the push and makes sure that we don't keep resending old rows.							$ran_okay:=PgQuery_Run ($insert_object)							PgQuery_SetSQLStatement ($insert_object;"")  // Free up the memory taken by the SQL statement.							If ($ran_okay=False)					PgSQL_Execute ($connection_id;"ROLLBACK;")					$item_index:=$items_count+1  // Break the loop. 				Else 					PgSQL_Execute ($connection_id;"COMMIT;")									^conid_update_statement^				End if 							^delete_records_statement^										End if 				End for each		End if End if	$0:=$ran_okayIf ($ran_okay)  // Push an entry even if no records need to be sent.	pgio_Push_PushLogEntry ($connection_object;0;$table_name_in_postgres_text;$items_count)End if Code_End (Current method name)