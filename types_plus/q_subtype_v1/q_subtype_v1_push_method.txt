//%attributes = {"invisible":true,"folder":"PgSQL_pgIO","lang":"en"} comment added and reserved by 4D.If (False)	pgIO_PushChanges_QSubType	  // DESCRIPTION: Push [QSubType] records to ascendco.q_subtype.	If (False)  // The field names and types of ascendco.q_subtype_1 are found below.		  // ascendco.q_subtype_1 is both an updatable view, and a type.		  //// types_plus.q_subtype_v1 is both an updatable view, and a type.//   id                             uuid,//   qtype_id                       uuid,//   qlevel_id                      uuid,//   facility_group_id              uuid,//   facility_id                    uuid,//   hsys_id                        uuid,//   last_updated_by_data_file_id   uuid,//   created_dts                    timestamp,//   updated_dts                    timestamp,//   is_available_in_assembly       boolean,//   is_available_in_decon          boolean,//   marked_for_deletion            boolean,//   is_for_inv                     boolean,//   is_active                      boolean,//   ascendco_name                  citext,//   updated_by                     citext,//   type_                          citext,//   available_for                  citext,//   created_by                     citext,//   name_                          citext,//   item_type_ids                  jsonb	End if	  // Note: This routine does *not* check if the push is enabled.       What?	  //       That responsibility is delegated to the calling routine.    Why?	  //       It makes it much simpler to test, develop, and quickly	  //       run a job, in case of emergency.                            See:	  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/1596588056/A+Note+on+Push+Checking+Responsibilities	// Insert the following declarations into Compiler_PgIOPush_and_SetupC_BOOLEAN(pgIO_PushChanges_QSubType;$0)C_OBJECT(pgIO_PushChanges_QSubType;$1)C_LONGINT(pgIO_PushChanges_QSubType;$2)	  // CREATED BY: PgBuildInsert_GenerateCode	  // DATE: Dec 27, 2020	  // LAST MODIFIED:End if   // ============================================Code_Start (Current method name)C_BOOLEAN($0;$ran_okay)C_OBJECT($1;$connection_o)C_LONGINT($2;$format_version_number_in)$connection_o:=$1  // Pass a good connection object or you're toast.$format_version_number_in:=0If (Count parameters>=2)	$format_version_number_in:=$2End if$ran_okay:=False  //------------------------------------------------------------------------  // Setup environment  //------------------------------------------------------------------------C_OBJECT($configuration_o)$configuration_o:=PgIOPushConfig_New (New object(\"connection_object";$connection_o;\"format_version_number";$format_version_number_in;\"table_pointer";->[QSubType];\"conid_field_pointer";->[QSubType]ConID;\"table_name_in_postgres";"q_subtype";\"target_path";"ascendco.q_subtype"))  // The path for tables = the qualified name. For passthroughs, it's a bit different.C_BOOLEAN($setup_looks_okay)C_BOOLEAN($push_is_not_already_in_progress)$setup_looks_okay:=PgConfigTarget_SetupLooksOkay ($configuration_o)$push_is_not_already_in_progress:=Not(PgConfigTarget_PushIsInProgress ($configuration_o.target_id))If ($setup_looks_okay=False)	Code_Err ("PgSQL_PushSetupError";JSON Stringify($configuration_o;*))End ifIf ($setup_looks_okay & $push_is_not_already_in_progress)	$ran_okay:=True  // Set to false if the push fails.	  //-------------------------------------------------------	  // Open and lock the audit record	  //-------------------------------------------------------	  // If PgConfig is active, after the line below there's a new [PgConfigPushAudit] record loaded, and locked to other processes.	PgIO_Push_OnStart ($configuration_o;Current method name)	  //-------------------------------------------------------	  // Find the unsent data	  //-------------------------------------------------------	  // Note: These locals are also stashed in $configuration_o elements. Because transition.	C_LONGINT($first_conid_to_send_l)	C_LONGINT($last_conid_to_send_l)	C_LONGINT($records_count)	PgConfigTarget_GetConIDs ($configuration_o.target_id;->$first_conid_to_send_l;->$last_conid_to_send_l)	$configuration_o.records_count:=PgConfigTarget_LoadByConIDs ($configuration_o.table_pointer;$configuration_o.conid_field_pointer;$first_conid_to_send_l;$last_conid_to_send_l)	PgConfigPushAudit_SetRecordCnt ($configuration_o.records_count)  // Copy the value to the tracking record.	  //-------------------------------------------------------	  // Prepare and push the data	  //-------------------------------------------------------	  // Even if there's nothing to push, need the object defined for the PgConfigPushAudit_Finish call.	C_OBJECT($insert_o)	$insert_o:=PgQuery_New ($connection_o;"";Current method name)	If ($configuration_o.records_count=0)		$ran_okay:=True	Else		PgConfigTarget_DoSyncWait ($configuration_o.target_id)  // Give pending *saves* time to catch up with the max *assigned* ConID.		C_TEXT($cr)		C_TEXT($tab)		C_TEXT($sq)		$cr:=Char(Carriage return)		$tab:=Char(Tab)		$sq:=Char(Quote)		C_LONGINT($maximum_push_bytes)		$maximum_push_bytes:=Iam_GetPGMaximumPushKB *1024  // We want bytes to compare to the results from calling Length($values_text)		C_TEXT($data_file_id)		$data_file_id:=PgConvert_UUID_ToPG_For_INSERT (<>sync_dataFileID_t)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		  // Fold the data into values statements.		C_BLOB($code_blob)  // Accumulate in a BLOB, crazy faster than accumulating in a text var.		SET BLOB SIZE($code_blob;0)		C_LONGINT($push_data_size_bytes)		C_BOOLEAN($push_now)		C_TEXT($clause_text)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		C_LONGINT($record_index)		For ($record_index;1;$configuration_o.records_count)			If (BLOB size($code_blob)=0)  // Add the code to open up the function call and array parameter.				TEXT TO BLOB("select * from "+$configuration_o.pg_insert_function_name+"(array["+$cr;$code_blob;UTF8 text without length;*)			End if			  // GOTO SELECTED RECORD. Yeah, it rules. See:			  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/572817462/Loading+Data+Efficiently+for+Pushing+to+Postgres			GOTO SELECTED RECORD([QSubType];$record_index)			$last_conid_actually_sent_l:=[QSubType]ConID  // Selection is sorted by ConID.			$clause_text:=""			$clause_text:=$clause_text+"("			Case of   // Each supported version has a case below. Older versions are left in place for testing in case we need to patch a lagging deployments.					: ($configuration_o.format_version_number=1) // Added: Dec 27, 2020	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([QSubType]ID)+","// q_subtype.id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([QSubType]QTypeID)+","// q_subtype.qtype_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([QSubType]QLevelID)+","// q_subtype.qlevel_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([QSubType]FacilityGroupID)+","// q_subtype.facility_group_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([QSubType]FacilityID)+","// q_subtype.facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([QSubType]HsysID)+","// q_subtype.hsys_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([QSubType]LastUpdatedByDataFileID)+","// q_subtype.last_updated_by_data_file_id	$clause_text:=$clause_text+PgConvert_DTS_ToPG([QSubType]CreatedDTS)+","// q_subtype.created_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([QSubType]UpdatedDTS)+","// q_subtype.updated_dts	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([QSubType]isAvailableInAssembly)+","// q_subtype.is_available_in_assembly	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([QSubType]isAvailableInDecon)+","// q_subtype.is_available_in_decon	$clause_text:=$clause_text+PgConvert_DateIsNotEmpty_ToPG([QSubType]DeletedRecordDate)+","// System field: marked_for_deletion	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([QSubType]isForInv)+","// q_subtype.is_for_inv	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([QSubType]isActive)+","// q_subtype.is_active	$clause_text:=$clause_text+PgConvert_Text_ToPG([QSubType]AscendcoName)+","// q_subtype.ascendco_name	$clause_text:=$clause_text+PgConvert_Text_ToPG([QSubType]UpdatedBy)+","// q_subtype.updated_by	$clause_text:=$clause_text+PgConvert_Text_ToPG([QSubType]Type)+","// q_subtype.type_	$clause_text:=$clause_text+PgConvert_Text_ToPG([QSubType]AvailableFor)+","// q_subtype.available_for	$clause_text:=$clause_text+PgConvert_Text_ToPG([QSubType]CreatedBy)+","// q_subtype.created_by	$clause_text:=$clause_text+PgConvert_Text_ToPG([QSubType]Name)+","// q_subtype.name_	$clause_text:=$clause_text+PgConvert_Object_ToPG([QSubType]ItemTypeIDs)// q_subtype.item_type_ids			End case			$clause_text:=$clause_text+")"			$push_data_size_bytes:=BLOB size($code_blob)+Length($clause_text)			Case of				: ($record_index=$configuration_o.records_count)  // We've gone through all of the records.					$push_now:=True				: ($push_data_size_bytes>=$maximum_push_bytes)  // We've filled the buffer.					$push_now:=True				Else   // Keep on building the VALUES.					$push_now:=False			End case			If ($push_now=False)				$clause_text:=$clause_text+","+$cr  // We now *know* that we're going to add another value (statement), so we also know that we need a comma. The last (value) does *not* have a comma.			Else				$clause_text:=$clause_text+"]::"+$configuration_o.pg_type_name+"[]);"  // Like hsys_v1[]			End if			TEXT TO BLOB($clause_text;$code_blob;UTF8 text without length;*)			$clause_text:=""			If ($push_now)  // We've filled our buffer (based on max KB from IAM) or reached the last record. Push!				  // This doubles memory consumption briefly. I asked Rob about a command that accepts a BLOB instead of text.				  // He said "no" as it would require a text copy internally anyway, so it won't help. If memory is an issue,				  // write to disk instead of text or BLOB and then use Document to text to load the block in one go.				C_TEXT($push_text)  // The VALUES are built up in the loop below. When we've got all the records, or have filled our self-defined buffer, a push is sent.				$push_text:=BLOB to text($code_blob;UTF8 text without length)				SET BLOB SIZE($code_blob;0)  // Free up the RAM.				If (False)					SET TEXT TO PASTEBOARD($push_text)				End if				  // Jam the text right into the object...not calling PgQuery_SetSQLStatement here in case text is built (doubled) by for 4D for the parameter.				OB SET($insert_o;PgQuery_Statement_SQL;$push_text)				$push_text:=""  // Clear this now! It frees up memory before the push and makes sure that we don't keep resending old rows.				$ran_okay:=PgQuery_Run ($insert_o)				PgQuery_SetSQLStatement ($insert_o;"")  // Free up the memory taken by the SQL statement.				If ($ran_okay)					PgSQL_Execute ($configuration_o.connection_id;"COMMIT;")					$configuration_o.ran_okay:=$ran_okay					  //-------------------------------------------------------					  // Update the last sent ConID					  //-------------------------------------------------------					  // This is why we sort by ConID up at the top. We're chunking through the number line and at each success, we plant a flag saying, "got this far!"					PgConfigLastPushed_SetConID ($configuration_o.target_id;$configuration_o.filter_id;$last_conid_actually_sent_l;True)  // Add if missing...but it shouldn't be missing.				Else					PgSQL_Execute ($configuration_o.connection_id;"ROLLBACK;")					$record_index:=$configuration_o.records_count+1  // Break the loop.				End if			End if		End for	End if	UNLOAD RECORD([QSubType])	  //-------------------------------------------------------	  // Close and unlock the audit record & do logging	  //-------------------------------------------------------	$configuration_o.ran_okay:=$ran_okay  // Put this back into the configuration/status objects for the following subroutines.	PgIO_Push__CheckIt ($configuration_o;Current method name)	PgIO_Push_OnFinish ($configuration_o;$insert_o)End if$0:=$ran_okayCode_End (Current method name)