-- Create a view onto rep formatted as rep_v1.-- If rep changes, you can update the view to handle the modification smoothly.-- Note: This view is automatically a custom type, with an array type to match. See types_plus.insert_rep_v1.DROP VIEW IF EXISTS types_plus.rep_v1 CASCADE;-- Careful!CREATE OR REPLACE VIEW types_plus.rep_v1 AS select id,        user_id,        hsys_id,        sup_id,        created_dts,        updated_dts,        marked_for_deletion,        name_,        phone,        email,        created_by,        updated_by   from rep;ALTER TABLE types_plus.rep_v1    OWNER TO user_change_structure;-- Create a casting function to convert rep rows into the compound type format rep_v1.-- If rep changes, you can update the casting to handle the modification smoothly.CREATE OR REPLACE FUNCTION types_plus.rep_to_v1 (rep_in rep)  RETURNS rep_v1AS $BODY$                   SELECT			rep_in.id,			rep_in.user_id,			rep_in.hsys_id,			rep_in.sup_id,			rep_in.created_dts,			rep_in.updated_dts,			rep_in.marked_for_deletion,			rep_in.name_,			rep_in.phone,			rep_in.email,			rep_in.created_by,			rep_in.updated_by               $BODY$LANGUAGE sql;  ALTER FUNCTION types_plus.rep_to_v1 (rep_in rep)	OWNER TO user_bender;-- Create/recreate the CAST. Use this to convert rep rows into the rep_v1 compound type format using the following syntax:-- select rep::rep_v1 from repDROP CAST IF EXISTS (rep as rep_v1);CREATE CAST (rep as rep_v1) WITH FUNCTION types_plus.rep_to_v1(rep);-- Create a function to accept an array of rows formatted as rep_v1 for UPSERT into rep.DROP FUNCTION IF EXISTS types_plus.insert_rep_v1 (types_plus.rep_v1[]);  CREATE OR REPLACE FUNCTION types_plus.insert_rep_v1 (data_in types_plus.rep_v1[])  RETURNS intAS $BODY$ -- The CTE below is a roundabout way of returning an insertion count from a pure SQL function in Postgres.with inserted_rows as (        INSERT INTO rep (			id,			user_id,			hsys_id,			sup_id,			created_dts,			updated_dts,			marked_for_deletion,			name_,			phone,			email,			created_by,			updated_by)                  SELECT			rows_in.id,			rows_in.user_id,			rows_in.hsys_id,			rows_in.sup_id,			rows_in.created_dts,			rows_in.updated_dts,			rows_in.marked_for_deletion,			rows_in.name_,			rows_in.phone,			rows_in.email,			rows_in.created_by,			rows_in.updated_by                      FROM unnest(data_in) as rows_in                  ON CONFLICT(id) DO UPDATE SET			user_id = EXCLUDED.user_id,			hsys_id = EXCLUDED.hsys_id,			sup_id = EXCLUDED.sup_id,			created_dts = EXCLUDED.created_dts,			updated_dts = EXCLUDED.updated_dts,			marked_for_deletion = EXCLUDED.marked_for_deletion,			name_ = EXCLUDED.name_,			phone = EXCLUDED.phone,			email = EXCLUDED.email,			created_by = EXCLUDED.created_by,			updated_by = EXCLUDED.updated_by          returning 1 as row_counter)         select sum(row_counter)::integer from inserted_rows; $BODY$LANGUAGE sql;  ALTER FUNCTION types_plus.insert_rep_v1(types_plus.rep_v1[])	OWNER TO user_bender;