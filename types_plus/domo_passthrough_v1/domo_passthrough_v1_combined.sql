-- Create a view onto domo_passthrough formatted as domo_passthrough_v1.-- If domo_passthrough changes, you can update the view to handle the modification smoothly.-- Note: This view is automatically a custom type, with an array type to match. See types_plus.insert_domo_passthrough_v1.DROP VIEW IF EXISTS types_plus.domo_passthrough_v1 CASCADE;-- Careful!CREATE OR REPLACE VIEW types_plus.domo_passthrough_v1 AS select source_id,        hsys_id,        facility_id,        view_version,        dataset_name,        data   from domo_passthrough;ALTER TABLE types_plus.domo_passthrough_v1    OWNER TO user_change_structure;-- Create a casting function to convert domo_passthrough rows into the compound type format domo_passthrough_v1.-- If domo_passthrough changes, you can update the casting to handle the modification smoothly.CREATE OR REPLACE FUNCTION types_plus.domo_passthrough_to_v1 (domo_passthrough_in domo_passthrough)  RETURNS domo_passthrough_v1AS $BODY$        SELECT			domo_passthrough_in.source_id,			domo_passthrough_in.hsys_id,			domo_passthrough_in.facility_id,			domo_passthrough_in.view_version,			domo_passthrough_in.dataset_name,			domo_passthrough_in.data$BODY$LANGUAGE sql;ALTER FUNCTION types_plus.domo_passthrough_to_v1 (domo_passthrough_in domo_passthrough) OWNER TO user_bender;-- Create a view onto domo_passthrough formatted as domo_passthrough_v1.-- If domo_passthrough changes, you can update the view to handle the modification smoothly.-- Note: This view is automatically a custom type, with an array type to match. See types_plus.insert_domo_passthrough_v1.DROP VIEW IF EXISTS types_plus.domo_passthrough_v1 CASCADE;-- Careful!CREATE OR REPLACE VIEW types_plus.domo_passthrough_v1 AS select source_id,        hsys_id,        facility_id,        view_version,        dataset_name,        data   from domo_passthrough;ALTER TABLE types_plus.domo_passthrough_v1    OWNER TO user_change_structure;-- Create a casting function to convert domo_passthrough rows into the compound type format domo_passthrough_v1.-- If domo_passthrough changes, you can update the casting to handle the modification smoothly.CREATE OR REPLACE FUNCTION types_plus.domo_passthrough_to_v1 (domo_passthrough_in domo_passthrough)  RETURNS domo_passthrough_v1AS $BODY$        SELECT			domo_passthrough_in.source_id,			domo_passthrough_in.hsys_id,			domo_passthrough_in.facility_id,			domo_passthrough_in.view_version,			domo_passthrough_in.dataset_name,			domo_passthrough_in.data$BODY$LANGUAGE sql;ALTER FUNCTION types_plus.domo_passthrough_to_v1 (domo_passthrough_in domo_passthrough) OWNER TO user_bender;-- Create/recreate the CAST. Use this to convert domo_passthrough rows into the domo_passthrough_v1 compound type format using the following syntax:-- select domo_passthrough::domo_passthrough_v1 from domo_passthroughDROP CAST IF EXISTS (domo_passthrough as domo_passthrough_v1);CREATE CAST (domo_passthrough as domo_passthrough_v1) WITH FUNCTION types_plus.domo_passthrough_to_v1(domo_passthrough);-- Create a function to accept an array of rows formatted as domo_passthrough_v1 for UPSERT into domo_passthrough.DROP FUNCTION IF EXISTS types_plus.insert_domo_passthrough_v1 (types_plus.domo_passthrough_v1[]);CREATE OR REPLACE FUNCTION types_plus.insert_domo_passthrough_v1 (data_in types_plus.domo_passthrough_v1[])  RETURNS intAS $BODY$-- The CTE below is a roundabout way of returning an insertion count from a pure SQL function in Postgres.-- 2020-04-05: Updated constraint clause to to match unqiue index name in v2 of table.with inserted_rows as (        INSERT INTO domo_passthrough (			source_id,			hsys_id,			facility_id,			view_version,			dataset_name,			data)        SELECT			rows_in.source_id,			rows_in.hsys_id,			rows_in.facility_id,			rows_in.view_version,			rows_in.dataset_name,			rows_in.data        FROM unnest(data_in) as rows_in        ON CONFLICT ON CONSTRAINT domo_passthrough_key_unique DO UPDATE SET			hsys_id         = EXCLUDED.hsys_id,			facility_id     = EXCLUDED.facility_id,			view_version    = EXCLUDED.view_version,			data            = EXCLUDED.data        returning 1 as row_counter)    select sum(row_counter)::integer from inserted_rows;$BODY$LANGUAGE sql;ALTER FUNCTION types_plus.insert_domo_passthrough_v1(types_plus.domo_passthrough_v1[]) OWNER TO user_bender;