-- Create a function to accept an array of rows formatted as text_collection_v1 for UPSERT into text_collection.DROP FUNCTION IF EXISTS types_plus.insert_text_collection_v1 (text[], boolean, uuid, citext);DROP FUNCTION IF EXISTS types_plus.insert_text_collection_v1 (text_id[], boolean, uuid, citext);CREATE OR REPLACE FUNCTION types_plus.insert_text_collection_v1 (    data_in                text_text[],    mark_for_retention_in  boolean  DEFAULT false,    facility_id_in         uuid     DEFAULT '00000000-0000-0000-0000-000000000000'::uuid,    collection_name_in     citext   DEFAULT '')RETURNS uuidAS $BODY$-- First, add the new collection and get back its ID for use in the rest of the script.WITH new_collection AS (  INSERT INTO text_collection (              retain,              facility_id,              collection_name)    VALUES (mark_for_retention_in,            facility_id_in,            collection_name_in)-- Note: ON CONFLICT on a partial index requires the WHERE clause to be repeated here in ON CONFLICT.ON CONFLICT (collection_name) WHERE collection_name <> '' DO UPDATE SET            retain      = EXCLUDED.retain,            facility_id = EXCLUDED.facility_idRETURNING id)-- Now, unpack the incoming array of strings, and insert each one into-- text_collectoin_item, along with the ID of the text_collection just created.INSERT INTO text_collection_item (   	   collection_id,       text,       source_id)SELECT DISTINCT ON (rows_in.text)      new_collection.id,      rows_in.text,      rows_in.id FROM new_collection,      unnest(data_in) as rows_in -- Silently remove duplicate strings from the list. ON CONFLICT (collection_id, text) DO UPDATE SET      source_id = EXCLUDED.source_id-- Everything is done, return the new collection's ID to the client. -- RETURNING is a *very* cool Postgres extension to standard SQL. -- Earlier, we used it to get the new ID out of the CTE for reuse -- by the main query. Now, we're returning that ID to the client -- for whatever purpose they have.RETURNING collection_id;$BODY$LANGUAGE sql;ALTER FUNCTION types_plus.insert_text_collection_v1(text_text[], boolean, uuid, citext)	OWNER TO user_bender;