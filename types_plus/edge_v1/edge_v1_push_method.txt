//%attributes = {"invisible":true,"folder":"PgSQL_pgIO","lang":"en"} comment added and reserved by 4D.If (False)	pgIO_Edge_Push	  // DESCRIPTION: Push [Edge] records to ascendco.edge.	If (False)  // The field names and types of types_plus.edge_1 are found below.		  // types_plus.edge_v1 is both an updatable view, and a type.//   id                            uuid,//   sequence_                     uuid,//   from_scan_at_facility_id      uuid,//   from_associated_to_id         uuid,//   to_associated_to_id           uuid,//   from_web_user_id              uuid,//   from_assembly_id              uuid,//   from_scan_id                  uuid,//   from_sterilizer_load_id       uuid,//   from_facility_location_id     uuid,//   from_facility_id              uuid,//   from_washer_load_id           uuid,//   from_scase_id                 uuid,//   from_clinic_id                uuid,//   from_facility_department_id   uuid,//   hsys_id                       uuid,//   to_scan_id                    uuid,//   to_scan_at_facility_id        uuid,//   to_web_user_id                uuid,//   to_user_name                  uuid,//   to_facility_location_id       uuid,//   to_sterilizer_load_id         uuid,//   to_washer_load_id             uuid,//   to_facility_id                uuid,//   to_scase_id                   uuid,//   to_clinic_id                  uuid,//   to_facility_department_id     uuid,//   to_assembly_id                uuid,//   from_node_dts                 timestamp,//   to_node_dts                   timestamp,//   created_dts                   timestamp,//   updated_dts                   timestamp,//   seconds                       integer,//   num_inst                      integer,//   inv_id                        citext,//   from_node                     citext,//   to_node                       citext,//   from_to_node                  citext,//   from_associated_to            citext,//   to_associated_to              citext,//   from_user_name                citext,//   source_                       citext,//   is_fake                       citext,//   path_                         citext	End if	  // Note: This routine does *not* check if the push is enabled.       What?	  //       That responsibility is delegated to the calling routine.    Why?	  //       It makes it much simpler to test, develop, and quickly	  //       run a job, in case of emergency.                            See:	  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/1596588056/A+Note+on+Push+Checking+Responsibilities	// Insert the following declarations into Compiler_PgIOPush_and_SetupC_BOOLEAN(pgIO_Edge_Push;$0)C_OBJECT(pgIO_Edge_Push;$1)C_LONGINT(pgIO_Edge_Push;$2)	  // CREATED BY: PgBuildInsert_GenerateCode	  // DATE: May 10, 2021	  // LAST MODIFIED:End if   // ============================================Code_Start (Current method name)C_BOOLEAN($0;$ran_okay)C_OBJECT($1;$connection_o)C_LONGINT($2;$format_version_number_in)$connection_o:=$1  // Pass a good connection object or you're toast.$format_version_number_in:=0If (Count parameters>=2)	$format_version_number_in:=$2End if$ran_okay:=False  //------------------------------------------------------------------------  // Setup environment  //------------------------------------------------------------------------C_OBJECT($configuration_o)$configuration_o:=PgIOPushConfig_New (New object(\"connection_object";$connection_o;\"format_version_number";$format_version_number_in;\"table_pointer";->[Edge];\"conid_field_pointer";->[Edge]ConID;\"table_name_in_postgres";"edge";\"target_path";"ascendco.edge"))  // The path for tables = the qualified name. For passthroughs, it's a bit different.C_BOOLEAN($setup_looks_okay)C_BOOLEAN($push_is_not_already_in_progress)C_BOOLEAN($push_is_not_disabled_after_fail)$setup_looks_okay:=PgConfigTarget_SetupLooksOkay ($configuration_o)$push_is_not_already_in_progress:=Not(PgConfigTarget_PushIsInProgress ($configuration_o.target_id))$push_is_not_disabled_after_fail:=Not(PgConfigTarget_IsDisabledByFail ($configuration_o.target_id))If ($setup_looks_okay=False)	Code_Err ("PgSQL_PushSetupError";JSON Stringify($configuration_o;*))End ifIf ($setup_looks_okay & $push_is_not_disabled_after_fail & $push_is_not_already_in_progress)	$ran_okay:=True  // Set to false if the push fails.	  //-------------------------------------------------------	  // Open and lock the audit record	  //-------------------------------------------------------	  // If PgConfig is active, after the line below there's a new [PgConfigPushAudit] record loaded, and locked to other processes.	PgIO_Push_OnStart ($configuration_o;Current method name)	  //-------------------------------------------------------	  // Find the unsent data	  //-------------------------------------------------------	  // Note: These locals are also stashed in $configuration_o elements. Because transition.	C_LONGINT($first_conid_to_send_l)	C_LONGINT($last_conid_to_send_l)	C_LONGINT($records_count)	PgConfigTarget_GetConIDs ($configuration_o.target_id;->$first_conid_to_send_l;->$last_conid_to_send_l)	$configuration_o.records_count:=PgConfigTarget_LoadByConIDs ($configuration_o.table_pointer;$configuration_o.conid_field_pointer;$first_conid_to_send_l;$last_conid_to_send_l)	PgConfigPushAudit_SetRecordCnt ($configuration_o.records_count)  // Copy the value to the tracking record.	  //-------------------------------------------------------	  // Prepare and push the data	  //-------------------------------------------------------	  // Even if there's nothing to push, need the object defined for the PgConfigPushAudit_Finish call.	C_OBJECT($insert_o)	$insert_o:=PgQuery_New ($connection_o;"";Current method name)	If ($configuration_o.records_count=0)		$ran_okay:=True	Else		PgConfigTarget_DoSyncWait ($configuration_o.target_id)  // Give pending *saves* time to catch up with the max *assigned* ConID.		C_TEXT($cr)		C_TEXT($tab)		C_TEXT($sq)		$cr:=Char(Carriage return)		$tab:=Char(Tab)		$sq:=Char(Quote)		C_LONGINT($maximum_push_bytes)		$maximum_push_bytes:=Iam_GetPGMaximumPushKB *1024  // We want bytes to compare to the results from calling Length($values_text)		C_TEXT($data_file_id)		$data_file_id:=PgConvert_UUID_ToPG_For_INSERT (<>sync_dataFileID_t)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		  // Fold the data into values statements.		C_BLOB($code_blob)  // Accumulate in a BLOB, crazy faster than accumulating in a text var.		SET BLOB SIZE($code_blob;0)		C_LONGINT($push_data_size_bytes)		C_BOOLEAN($push_now)		C_TEXT($clause_text)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		C_LONGINT($record_index)		For ($record_index;1;$configuration_o.records_count)			If (BLOB size($code_blob)=0)  // Add the code to open up the function call and array parameter.				TEXT TO BLOB("select * from "+$configuration_o.pg_insert_function_name+"(array["+$cr;$code_blob;UTF8 text without length;*)			End if			  // GOTO SELECTED RECORD. Yeah, it rules. See:			  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/572817462/Loading+Data+Efficiently+for+Pushing+to+Postgres			GOTO SELECTED RECORD([Edge];$record_index)			$last_conid_actually_sent_l:=[Edge]ConID  // Selection is sorted by ConID.			$clause_text:=""			$clause_text:=$clause_text+"("			Case of   // Each supported version has a case below. Older versions are left in place for testing in case we need to patch a lagging deployments.					: ($configuration_o.format_version_number=1) // Added: May 10, 2021// Do NOT change the order of the lines below, or disable any of them. Ask me, if you need help. -- David	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ID)+","// edge.id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]Sequence)+","// edge.sequence_	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromScanAtFacilityID)+","// edge.from_scan_at_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromAssociatedToID)+","// edge.from_associated_to_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToAssociatedToID)+","// edge.to_associated_to_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromWebUserID)+","// edge.from_web_user_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromAssemblyID)+","// edge.from_assembly_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromScanID)+","// edge.from_scan_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromSterilizerLoadID)+","// edge.from_sterilizer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromFacilityLocationID)+","// edge.from_facility_location_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromFacilityID)+","// edge.from_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromWasherLoadID)+","// edge.from_washer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromSCaseID)+","// edge.from_scase_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromClinicID)+","// edge.from_clinic_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromFacilityDepartmentID)+","// edge.from_facility_department_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]HsysID)+","// edge.hsys_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToScanID)+","// edge.to_scan_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToScanAtFacilityID)+","// edge.to_scan_at_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToWebUserID)+","// edge.to_web_user_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToUserName)+","// edge.to_user_name	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToFacilityLocationID)+","// edge.to_facility_location_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToSterilizerLoadID)+","// edge.to_sterilizer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToWasherLoadID)+","// edge.to_washer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToFacilityID)+","// edge.to_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToSCaseID)+","// edge.to_scase_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToClinicID)+","// edge.to_clinic_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToFacilityDepartmentID)+","// edge.to_facility_department_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToAssemblyID)+","// edge.to_assembly_id	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]FromNodeDTS)+","// edge.from_node_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]ToNodeDTS)+","// edge.to_node_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]CreatedDTS)+","// edge.created_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]UpdatedDTS)+","// edge.updated_dts	$clause_text:=$clause_text+PgConvert_Number_ToPG([Edge]Seconds)+","// edge.seconds	$clause_text:=$clause_text+PgConvert_Number_ToPG([Edge]NumInst)+","// edge.num_inst	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]InvID)+","// edge.inv_id	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromNode)+","// edge.from_node	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]ToNode)+","// edge.to_node	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromToNode)+","// edge.from_to_node	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromAssociatedTo)+","// edge.from_associated_to	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]ToAssociatedTo)+","// edge.to_associated_to	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromUserName)+","// edge.from_user_name	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]Source)+","// edge.source_	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]isFake)+","// edge.is_fake	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]Path)// edge.path_			End case			$clause_text:=$clause_text+")"			$push_data_size_bytes:=BLOB size($code_blob)+Length($clause_text)			Case of				: ($record_index=$configuration_o.records_count)  // We've gone through all of the records.					$push_now:=True				: ($push_data_size_bytes>=$maximum_push_bytes)  // We've filled the buffer.					$push_now:=True				Else   // Keep on building the VALUES.					$push_now:=False			End case			If ($push_now=False)				$clause_text:=$clause_text+","+$cr  // We now *know* that we're going to add another value (statement), so we also know that we need a comma. The last (value) does *not* have a comma.			Else				$clause_text:=$clause_text+"]::"+$configuration_o.pg_type_name+"[]);"  // Like hsys_v1[]			End if			TEXT TO BLOB($clause_text;$code_blob;UTF8 text without length;*)			$clause_text:=""			If ($push_now)  // We've filled our buffer (based on max KB from IAM) or reached the last record. Push!				  // This doubles memory consumption briefly. I asked Rob about a command that accepts a BLOB instead of text.				  // He said "no" as it would require a text copy internally anyway, so it won't help. If memory is an issue,				  // write to disk instead of text or BLOB and then use Document to text to load the block in one go.				C_TEXT($push_text)  // The VALUES are built up in the loop below. When we've got all the records, or have filled our self-defined buffer, a push is sent.				$push_text:=BLOB to text($code_blob;UTF8 text without length)				SET BLOB SIZE($code_blob;0)  // Free up the RAM.				If (False)					SET TEXT TO PASTEBOARD($push_text)				End if				  // Jam the text right into the object...not calling PgQuery_SetSQLStatement here in case text is built (doubled) by for 4D for the parameter.				OB SET($insert_o;PgQuery_Statement_SQL;$push_text)				$push_text:=""  // Clear this now! It frees up memory before the push and makes sure that we don't keep resending old rows.				$ran_okay:=PgQuery_Run ($insert_o)				PgQuery_SetSQLStatement ($insert_o;"")  // Free up the memory taken by the SQL statement.				If ($ran_okay)					PgSQL_Execute ($configuration_o.connection_id;"COMMIT;")					$configuration_o.ran_okay:=$ran_okay					  //-------------------------------------------------------					  // Update the last sent ConID					  //-------------------------------------------------------					  // This is why we sort by ConID up at the top. We're chunking through the number line and at each success, we plant a flag saying, "got this far!"					PgConfigLastPushed_SetConID ($configuration_o.target_id;$configuration_o.filter_id;$last_conid_actually_sent_l;True)  // Add if missing...but it shouldn't be missing.				Else					PgSQL_Execute ($configuration_o.connection_id;"ROLLBACK;")					$record_index:=$configuration_o.records_count+1  // Break the loop.				End if			End if		End for	End if	UNLOAD RECORD([Edge])	  //-------------------------------------------------------	  // Close and unlock the audit record & do logging	  //-------------------------------------------------------	$configuration_o.ran_okay:=$ran_okay  // Put this back into the configuration/status objects for the following subroutines.	PgIO_Push__CheckIt ($configuration_o;Current method name)	PgIO_Push_OnFinish ($configuration_o;$insert_o)End if$0:=$ran_okayCode_End (Current method name)