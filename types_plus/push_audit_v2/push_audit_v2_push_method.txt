//%attributes = {"invisible":true,"folder":"PgSQL_pgIO","lang":"en"} comment added and reserved by 4D.If (False)	pgIO_PgConfigPushAudit_Push	  // DESCRIPTION: Push [PgConfigPushAudit] records to dba.push_audit.	If (False)  // The field names and types of types_plus.push_audit_2 are found below.		  // types_plus.push_audit_v2 is both an updatable view, and a type.//   id                            uuid,//   target_id                     uuid,//   data_file_id                  uuid,//   pg_config_target_version_id   uuid,//   start_local_dts               timestamp,//   end_utc_dts                   timestamp,//   end_local_dts                 timestamp,//   inserted_utc_dts              timestamptz,//   first_con_id                  integer,//   last_con_id                   integer,//   records_count                 integer,//   duration_seconds              integer,//   error_occurred                boolean,//   client_user_name              citext,//   inserted_by                   citext,//   push_method_name              citext,//   error_text                    citext,//   result_text                   citext	End if	  // Note: This routine does *not* check if the push is enabled.       What?	  //       That responsibility is delegated to the calling routine.    Why?	  //       It makes it much simpler to test, develop, and quickly	  //       run a job, in case of emergency.                            See:	  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/1596588056/A+Note+on+Push+Checking+Responsibilities	// Insert the following declarations into Compiler_PgIOPush_and_SetupC_BOOLEAN(pgIO_PgConfigPushAudit_Push;$0)C_OBJECT(pgIO_PgConfigPushAudit_Push;$1)C_LONGINT(pgIO_PgConfigPushAudit_Push;$2)	  // CREATED BY: PgBuildInsert_GenerateCode	  // DATE: May 8, 2021	  // LAST MODIFIED:End if   // ============================================Code_Start (Current method name)C_BOOLEAN($0;$ran_okay)C_OBJECT($1;$connection_o)C_LONGINT($2;$format_version_number_in)$connection_o:=$1  // Pass a good connection object or you're toast.$format_version_number_in:=0If (Count parameters>=2)	$format_version_number_in:=$2End if$ran_okay:=False  //------------------------------------------------------------------------  // Setup environment  //------------------------------------------------------------------------C_OBJECT($configuration_o)$configuration_o:=PgIOPushConfig_New (New object(\"connection_object";$connection_o;\"format_version_number";$format_version_number_in;\"table_pointer";->[PgConfigPushAudit];\"conid_field_pointer";->[PgConfigPushAudit]ConID;\"table_name_in_postgres";"push_audit";\"target_path";"dba.push_audit"))  // The path for tables = the qualified name. For passthroughs, it's a bit different.C_BOOLEAN($setup_looks_okay)C_BOOLEAN($push_is_not_already_in_progress)C_BOOLEAN($push_is_not_disabled_after_fail)$setup_looks_okay:=PgConfigTarget_SetupLooksOkay ($configuration_o)$push_is_not_already_in_progress:=Not(PgConfigTarget_PushIsInProgress ($configuration_o.target_id))$push_is_not_disabled_after_fail:=Not(PgConfigTarget_IsDisabledByFail ($configuration_o.target_id))If ($setup_looks_okay=False)	Code_Err ("PgSQL_PushSetupError";JSON Stringify($configuration_o;*))End ifIf ($setup_looks_okay & $push_is_not_disabled_after_fail & $push_is_not_already_in_progress)	$ran_okay:=True  // Set to false if the push fails.	  //-------------------------------------------------------	  // Open and lock the audit record	  //-------------------------------------------------------	  // If PgConfig is active, after the line below there's a new [PgConfigPushAudit] record loaded, and locked to other processes.	PgIO_Push_OnStart ($configuration_o;Current method name)	  //-------------------------------------------------------	  // Find the unsent data	  //-------------------------------------------------------	  // Note: These locals are also stashed in $configuration_o elements. Because transition.	C_LONGINT($first_conid_to_send_l)	C_LONGINT($last_conid_to_send_l)	C_LONGINT($records_count)	PgConfigTarget_GetConIDs ($configuration_o.target_id;->$first_conid_to_send_l;->$last_conid_to_send_l)	$configuration_o.records_count:=PgConfigTarget_LoadByConIDs ($configuration_o.table_pointer;$configuration_o.conid_field_pointer;$first_conid_to_send_l;$last_conid_to_send_l)	PgConfigPushAudit_SetRecordCnt ($configuration_o.records_count)  // Copy the value to the tracking record.	  //-------------------------------------------------------	  // Prepare and push the data	  //-------------------------------------------------------	  // Even if there's nothing to push, need the object defined for the PgConfigPushAudit_Finish call.	C_OBJECT($insert_o)	$insert_o:=PgQuery_New ($connection_o;"";Current method name)	If ($configuration_o.records_count=0)		$ran_okay:=True	Else		PgConfigTarget_DoSyncWait ($configuration_o.target_id)  // Give pending *saves* time to catch up with the max *assigned* ConID.		C_TEXT($cr)		C_TEXT($tab)		C_TEXT($sq)		$cr:=Char(Carriage return)		$tab:=Char(Tab)		$sq:=Char(Quote)		C_LONGINT($maximum_push_bytes)		$maximum_push_bytes:=Iam_GetPGMaximumPushKB *1024  // We want bytes to compare to the results from calling Length($values_text)		C_TEXT($data_file_id)		$data_file_id:=PgConvert_UUID_ToPG_For_INSERT (<>sync_dataFileID_t)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		  // Fold the data into values statements.		C_BLOB($code_blob)  // Accumulate in a BLOB, crazy faster than accumulating in a text var.		SET BLOB SIZE($code_blob;0)		C_LONGINT($push_data_size_bytes)		C_BOOLEAN($push_now)		C_TEXT($clause_text)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		C_LONGINT($record_index)		For ($record_index;1;$configuration_o.records_count)			If (BLOB size($code_blob)=0)  // Add the code to open up the function call and array parameter.				TEXT TO BLOB("select * from "+$configuration_o.pg_insert_function_name+"(array["+$cr;$code_blob;UTF8 text without length;*)			End if			  // GOTO SELECTED RECORD. Yeah, it rules. See:			  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/572817462/Loading+Data+Efficiently+for+Pushing+to+Postgres			GOTO SELECTED RECORD([PgConfigPushAudit];$record_index)			$last_conid_actually_sent_l:=[PgConfigPushAudit]ConID  // Selection is sorted by ConID.			$clause_text:=""			$clause_text:=$clause_text+"("			Case of   // Each supported version has a case below. Older versions are left in place for testing in case we need to patch a lagging deployments.					: ($configuration_o.format_version_number=2) // Added: May 8, 2021// Do NOT change the order of the lines below, or disable any of them. Ask me, if you need help. -- David	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([PgConfigPushAudit]ID)+","// push_audit.id	$clause_text:=$clause_text+PgConvert_Number_ToPG+","// push_audit.id	$clause_text:=$clause_text+$data_file_id+","// System field: data_file_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([PgConfigPushAudit]PgConfigTargetVersionID)+","// push_audit.pg_config_target_version_id	$clause_text:=$clause_text+PgConvert_DTS_ToPG([PgConfigPushAudit]StartLocalDTS)+","// push_audit.start_local_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([PgConfigPushAudit]EndUTCDTS)+","// push_audit.end_utc_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([PgConfigPushAudit]EndLocalDTS)+","// push_audit.end_local_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG+","// push_audit.end_local_dts	$clause_text:=$clause_text+PgConvert_Number_ToPG([PgConfigPushAudit]FirstConID)+","// push_audit.first_con_id	$clause_text:=$clause_text+PgConvert_Number_ToPG([PgConfigPushAudit]LastConID)+","// push_audit.last_con_id	$clause_text:=$clause_text+PgConvert_Number_ToPG([PgConfigPushAudit]RecordsCount)+","// push_audit.records_count	$clause_text:=$clause_text+PgConvert_Number_ToPG([PgConfigPushAudit]DurationSeconds)+","// push_audit.duration_seconds	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([PgConfigPushAudit]ErrorOccurred)+","// push_audit.error_occurred	$clause_text:=$clause_text+PgConvert_Text_ToPG([PgConfigPushAudit]UserName)+","// push_audit.client_user_name	$clause_text:=$clause_text+PgConvert_Text_ToPG+","// push_audit.client_user_name	$clause_text:=$clause_text+PgConvert_Text_ToPG([PgConfigPushAudit]PushMethodName)+","// push_audit.push_method_name	$clause_text:=$clause_text+PgConvert_Text_ToPG([PgConfigPushAudit]ErrorText)+","// push_audit.error_text	$clause_text:=$clause_text+PgConvert_Text_ToPG([PgConfigPushAudit]ResultText)// push_audit.result_text			End case			$clause_text:=$clause_text+")"			$push_data_size_bytes:=BLOB size($code_blob)+Length($clause_text)			Case of				: ($record_index=$configuration_o.records_count)  // We've gone through all of the records.					$push_now:=True				: ($push_data_size_bytes>=$maximum_push_bytes)  // We've filled the buffer.					$push_now:=True				Else   // Keep on building the VALUES.					$push_now:=False			End case			If ($push_now=False)				$clause_text:=$clause_text+","+$cr  // We now *know* that we're going to add another value (statement), so we also know that we need a comma. The last (value) does *not* have a comma.			Else				$clause_text:=$clause_text+"]::"+$configuration_o.pg_type_name+"[]);"  // Like hsys_v1[]			End if			TEXT TO BLOB($clause_text;$code_blob;UTF8 text without length;*)			$clause_text:=""			If ($push_now)  // We've filled our buffer (based on max KB from IAM) or reached the last record. Push!				  // This doubles memory consumption briefly. I asked Rob about a command that accepts a BLOB instead of text.				  // He said "no" as it would require a text copy internally anyway, so it won't help. If memory is an issue,				  // write to disk instead of text or BLOB and then use Document to text to load the block in one go.				C_TEXT($push_text)  // The VALUES are built up in the loop below. When we've got all the records, or have filled our self-defined buffer, a push is sent.				$push_text:=BLOB to text($code_blob;UTF8 text without length)				SET BLOB SIZE($code_blob;0)  // Free up the RAM.				If (False)					SET TEXT TO PASTEBOARD($push_text)				End if				  // Jam the text right into the object...not calling PgQuery_SetSQLStatement here in case text is built (doubled) by for 4D for the parameter.				OB SET($insert_o;PgQuery_Statement_SQL;$push_text)				$push_text:=""  // Clear this now! It frees up memory before the push and makes sure that we don't keep resending old rows.				$ran_okay:=PgQuery_Run ($insert_o)				PgQuery_SetSQLStatement ($insert_o;"")  // Free up the memory taken by the SQL statement.				If ($ran_okay)					PgSQL_Execute ($configuration_o.connection_id;"COMMIT;")					$configuration_o.ran_okay:=$ran_okay					  //-------------------------------------------------------					  // Update the last sent ConID					  //-------------------------------------------------------					  // This is why we sort by ConID up at the top. We're chunking through the number line and at each success, we plant a flag saying, "got this far!"					PgConfigLastPushed_SetConID ($configuration_o.target_id;$configuration_o.filter_id;$last_conid_actually_sent_l;True)  // Add if missing...but it shouldn't be missing.				Else					PgSQL_Execute ($configuration_o.connection_id;"ROLLBACK;")					$record_index:=$configuration_o.records_count+1  // Break the loop.				End if			End if		End for	End if	UNLOAD RECORD([PgConfigPushAudit])	  //-------------------------------------------------------	  // Close and unlock the audit record & do logging	  //-------------------------------------------------------	$configuration_o.ran_okay:=$ran_okay  // Put this back into the configuration/status objects for the following subroutines.	PgIO_Push__CheckIt ($configuration_o;Current method name)	PgIO_Push_OnFinish ($configuration_o;$insert_o)End if$0:=$ran_okayCode_End (Current method name)