//%attributes = {"invisible":true,"folder":"PgSQL_pgIO","lang":"en"} comment added and reserved by 4D.If (False)	pgIO_Inv_Push	  // DESCRIPTION: Push [Inv] records to ascendco.inv.	If (False)  // The field names and types of types_plus.inv_2 are found below.		  // types_plus.inv_v2 is both an updatable view, and a type.//   id                            uuid,//   item_id                       uuid,//   item_arch_id                  uuid,//   facility_location_id          uuid,//   standard_faclity_id           uuid,//   store_at_facility_id          uuid,//   created_dts                   timestamp,//   updated_dts                   timestamp,//   serial_no_as_of_dts           timestamp,//   qty                           integer,//   flow                          integer,//   flow_long                     integer,//   par                           integer,//   last_seen_date                date,//   their_next_repair_date        date,//   last_sterilized_date          date,//   repair_last_repair_date       date,//   is_searched_but_not_found     boolean,//   marked_for_deletion           boolean,//   is_found                      boolean,//   is_go_live_perm_printed       boolean,//   is_sleeping                   boolean,//   is_handwritten_label          boolean,//   is_wrong_loc                  boolean,//   is_facility_loc_inherited     boolean,//   needs_repair                  boolean,//   is_deactivated                boolean,//   is_contents_incomplete        boolean,//   their_location                citext,//   category                      citext,//   their_name                    citext,//   their_id                      citext,//   created_by                    citext,//   updated_by                    citext,//   their_id_scrubbed             citext,//   crossing_status               citext,//   inv_no                        citext,//   their_raw_name                citext,//   comments_                     citext,//   their_bar_code                citext,//   loc_rack                      citext,//   loc_row                       citext,//   loc_bin                       citext,//   loc_note                      citext,//   serial_no                     citext,//   data_cleanse_classification   citext,//   repair_next_due               citext,//   repair_last_repaired_by       citext,//   msgs                          jsonb	End if	  // Note: This routine does *not* check if the push is enabled.       What?	  //       That responsibility is delegated to the calling routine.    Why?	  //       It makes it much simpler to test, develop, and quickly	  //       run a job, in case of emergency.                            See:	  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/1596588056/A+Note+on+Push+Checking+Responsibilities	// Insert the following declarations into Compiler_PgIOPush_and_SetupC_BOOLEAN(pgIO_Inv_Push;$0)C_OBJECT(pgIO_Inv_Push;$1)C_LONGINT(pgIO_Inv_Push;$2)	  // CREATED BY: PgBuildInsert_GenerateCode	  // DATE: Feb 1, 2021	  // LAST MODIFIED:End if   // ============================================Code_Start (Current method name)C_BOOLEAN($0;$ran_okay)C_OBJECT($1;$connection_o)C_LONGINT($2;$format_version_number_in)$connection_o:=$1  // Pass a good connection object or you're toast.$format_version_number_in:=0If (Count parameters>=2)	$format_version_number_in:=$2End if$ran_okay:=False  //------------------------------------------------------------------------  // Setup environment  //------------------------------------------------------------------------C_OBJECT($configuration_o)$configuration_o:=PgIOPushConfig_New (New object(\"connection_object";$connection_o;\"format_version_number";$format_version_number_in;\"table_pointer";->[Inv];\"conid_field_pointer";->[Inv]ConID;\"table_name_in_postgres";"inv";\"target_path";"ascendco.inv"))  // The path for tables = the qualified name. For passthroughs, it's a bit different.C_BOOLEAN($setup_looks_okay)C_BOOLEAN($push_is_not_already_in_progress)C_BOOLEAN($push_is_not_disabled_after_fail)$setup_looks_okay:=PgConfigTarget_SetupLooksOkay ($configuration_o)$push_is_not_already_in_progress:=Not(PgConfigTarget_PushIsInProgress ($configuration_o.target_id))$push_is_not_disabled_after_fail:=Not(PgConfigTarget_IsDisabledByFail ($configuration_o.target_id))If ($setup_looks_okay=False)	Code_Err ("PgSQL_PushSetupError";JSON Stringify($configuration_o;*))End ifIf ($setup_looks_okay & $push_is_not_disabled_after_fail & $push_is_not_already_in_progress)	$ran_okay:=True  // Set to false if the push fails.	  //-------------------------------------------------------	  // Open and lock the audit record	  //-------------------------------------------------------	  // If PgConfig is active, after the line below there's a new [PgConfigPushAudit] record loaded, and locked to other processes.	PgIO_Push_OnStart ($configuration_o;Current method name)	  //-------------------------------------------------------	  // Find the unsent data	  //-------------------------------------------------------	  // Note: These locals are also stashed in $configuration_o elements. Because transition.	C_LONGINT($first_conid_to_send_l)	C_LONGINT($last_conid_to_send_l)	C_LONGINT($records_count)	PgConfigTarget_GetConIDs ($configuration_o.target_id;->$first_conid_to_send_l;->$last_conid_to_send_l)	$configuration_o.records_count:=PgConfigTarget_LoadByConIDs ($configuration_o.table_pointer;$configuration_o.conid_field_pointer;$first_conid_to_send_l;$last_conid_to_send_l)	PgConfigPushAudit_SetRecordCnt ($configuration_o.records_count)  // Copy the value to the tracking record.	  //-------------------------------------------------------	  // Prepare and push the data	  //-------------------------------------------------------	  // Even if there's nothing to push, need the object defined for the PgConfigPushAudit_Finish call.	C_OBJECT($insert_o)	$insert_o:=PgQuery_New ($connection_o;"";Current method name)	If ($configuration_o.records_count=0)		$ran_okay:=True	Else		PgConfigTarget_DoSyncWait ($configuration_o.target_id)  // Give pending *saves* time to catch up with the max *assigned* ConID.		C_TEXT($cr)		C_TEXT($tab)		C_TEXT($sq)		$cr:=Char(Carriage return)		$tab:=Char(Tab)		$sq:=Char(Quote)		C_LONGINT($maximum_push_bytes)		$maximum_push_bytes:=Iam_GetPGMaximumPushKB *1024  // We want bytes to compare to the results from calling Length($values_text)		C_TEXT($data_file_id)		$data_file_id:=PgConvert_UUID_ToPG_For_INSERT (<>sync_dataFileID_t)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		  // Fold the data into values statements.		C_BLOB($code_blob)  // Accumulate in a BLOB, crazy faster than accumulating in a text var.		SET BLOB SIZE($code_blob;0)		C_LONGINT($push_data_size_bytes)		C_BOOLEAN($push_now)		C_TEXT($clause_text)		C_LONGINT($last_conid_actually_sent_l)  // Chunking, need to check and update after each push.		$last_conid_actually_sent_l:=0		C_LONGINT($record_index)		For ($record_index;1;$configuration_o.records_count)			If (BLOB size($code_blob)=0)  // Add the code to open up the function call and array parameter.				TEXT TO BLOB("select * from "+$configuration_o.pg_insert_function_name+"(array["+$cr;$code_blob;UTF8 text without length;*)			End if			  // GOTO SELECTED RECORD. Yeah, it rules. See:			  // https://ascendco.atlassian.net/wiki/spaces/SON/pages/572817462/Loading+Data+Efficiently+for+Pushing+to+Postgres			GOTO SELECTED RECORD([Inv];$record_index)			$last_conid_actually_sent_l:=[Inv]ConID  // Selection is sorted by ConID.			$clause_text:=""			$clause_text:=$clause_text+"("			Case of   // Each supported version has a case below. Older versions are left in place for testing in case we need to patch a lagging deployments.					: ($configuration_o.format_version_number=2) // Added: Feb 1, 2021	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Inv]ID)+","// inv.id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Inv]ItemID)+","// inv.item_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Inv]ItemArchID)+","// inv.item_arch_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Inv]FacilityLocationID)+","// inv.facility_location_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Inv]StandardFaclityID)+","// inv.standard_faclity_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Inv]StoreAtFacilityID)+","// inv.store_at_facility_id	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Inv]CreatedDTS)+","// inv.created_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Inv]UpdatedDTS)+","// inv.updated_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Inv]SerialNoAsOfDTS)+","// inv.serial_no_as_of_dts	$clause_text:=$clause_text+PgConvert_Number_ToPG([Inv]Qty)+","// inv.qty	$clause_text:=$clause_text+PgConvert_Number_ToPG([Inv]Flow)+","// inv.flow	$clause_text:=$clause_text+PgConvert_Number_ToPG([Inv]FlowLong)+","// inv.flow_long	$clause_text:=$clause_text+PgConvert_Number_ToPG([Inv]Par)+","// inv.par	$clause_text:=$clause_text+PgConvert_Date_ToPG([Inv]LastSeenDate)+","// inv.last_seen_date	$clause_text:=$clause_text+PgConvert_Date_ToPG([Inv]TheirNextRepairDate)+","// inv.their_next_repair_date	$clause_text:=$clause_text+PgConvert_Date_ToPG([Inv]LastSterilizedDate)+","// inv.last_sterilized_date	$clause_text:=$clause_text+PgConvert_Date_ToPG([Inv]Repair_LastRepairDate)+","// inv.repair_last_repair_date	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isSearchedButNotFound)+","// inv.is_searched_but_not_found	$clause_text:=$clause_text+PgConvert_DateIsNotEmpty_ToPG([Inv]DeletedRecordDate)+","// System field: marked_for_deletion	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isFound)+","// inv.is_found	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isGoLivePermPrinted)+","// inv.is_go_live_perm_printed	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isSleeping)+","// inv.is_sleeping	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isHandwrittenLabel)+","// inv.is_handwritten_label	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isWrongLoc)+","// inv.is_wrong_loc	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isFacilityLocInherited)+","// inv.is_facility_loc_inherited	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]NeedsRepair)+","// inv.needs_repair	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isDeactivated)+","// inv.is_deactivated	$clause_text:=$clause_text+PgConvert_Boolean_ToPG([Inv]isContentsIncomplete)+","// inv.is_contents_incomplete	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]TheirLocation)+","// inv.their_location	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Category)+","// inv.category	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]TheirName)+","// inv.their_name	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]TheirID)+","// inv.their_id	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]CreatedBy)+","// inv.created_by	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]UpdatedBy)+","// inv.updated_by	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]TheirID_Scrubbed)+","// inv.their_id_scrubbed	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]CrossingStatus)+","// inv.crossing_status	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]InvNo)+","// inv.inv_no	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]TheirRawName)+","// inv.their_raw_name	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Comments)+","// inv.comments_	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]TheirBarCode)+","// inv.their_bar_code	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Loc_Rack)+","// inv.loc_rack	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Loc_Row)+","// inv.loc_row	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Loc_Bin)+","// inv.loc_bin	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Loc_Note)+","// inv.loc_note	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]SerialNo)+","// inv.serial_no	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]DataCleanseClassification)+","// inv.data_cleanse_classification	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Repair_NextDue)+","// inv.repair_next_due	$clause_text:=$clause_text+PgConvert_Text_ToPG([Inv]Repair_LastRepairedBy)+","// inv.repair_last_repaired_by	$clause_text:=$clause_text+PgConvert_Object_ToPG([Inv]Msgs)// inv.msgs			End case			$clause_text:=$clause_text+")"			$push_data_size_bytes:=BLOB size($code_blob)+Length($clause_text)			Case of				: ($record_index=$configuration_o.records_count)  // We've gone through all of the records.					$push_now:=True				: ($push_data_size_bytes>=$maximum_push_bytes)  // We've filled the buffer.					$push_now:=True				Else   // Keep on building the VALUES.					$push_now:=False			End case			If ($push_now=False)				$clause_text:=$clause_text+","+$cr  // We now *know* that we're going to add another value (statement), so we also know that we need a comma. The last (value) does *not* have a comma.			Else				$clause_text:=$clause_text+"]::"+$configuration_o.pg_type_name+"[]);"  // Like hsys_v1[]			End if			TEXT TO BLOB($clause_text;$code_blob;UTF8 text without length;*)			$clause_text:=""			If ($push_now)  // We've filled our buffer (based on max KB from IAM) or reached the last record. Push!				  // This doubles memory consumption briefly. I asked Rob about a command that accepts a BLOB instead of text.				  // He said "no" as it would require a text copy internally anyway, so it won't help. If memory is an issue,				  // write to disk instead of text or BLOB and then use Document to text to load the block in one go.				C_TEXT($push_text)  // The VALUES are built up in the loop below. When we've got all the records, or have filled our self-defined buffer, a push is sent.				$push_text:=BLOB to text($code_blob;UTF8 text without length)				SET BLOB SIZE($code_blob;0)  // Free up the RAM.				If (False)					SET TEXT TO PASTEBOARD($push_text)				End if				  // Jam the text right into the object...not calling PgQuery_SetSQLStatement here in case text is built (doubled) by for 4D for the parameter.				OB SET($insert_o;PgQuery_Statement_SQL;$push_text)				$push_text:=""  // Clear this now! It frees up memory before the push and makes sure that we don't keep resending old rows.				$ran_okay:=PgQuery_Run ($insert_o)				PgQuery_SetSQLStatement ($insert_o;"")  // Free up the memory taken by the SQL statement.				If ($ran_okay)					PgSQL_Execute ($configuration_o.connection_id;"COMMIT;")					$configuration_o.ran_okay:=$ran_okay					  //-------------------------------------------------------					  // Update the last sent ConID					  //-------------------------------------------------------					  // This is why we sort by ConID up at the top. We're chunking through the number line and at each success, we plant a flag saying, "got this far!"					PgConfigLastPushed_SetConID ($configuration_o.target_id;$configuration_o.filter_id;$last_conid_actually_sent_l;True)  // Add if missing...but it shouldn't be missing.				Else					PgSQL_Execute ($configuration_o.connection_id;"ROLLBACK;")					$record_index:=$configuration_o.records_count+1  // Break the loop.				End if			End if		End for	End if	UNLOAD RECORD([Inv])	  //-------------------------------------------------------	  // Close and unlock the audit record & do logging	  //-------------------------------------------------------	$configuration_o.ran_okay:=$ran_okay  // Put this back into the configuration/status objects for the following subroutines.	PgIO_Push__CheckIt ($configuration_o;Current method name)	PgIO_Push_OnFinish ($configuration_o;$insert_o)End if$0:=$ran_okayCode_End (Current method name)