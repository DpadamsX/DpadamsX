-- Create a function to accept an array of rows formatted as inv_v2 for UPSERT into inv.DROP FUNCTION IF EXISTS types_plus.insert_inv_v2 (types_plus.inv_v2[]);  CREATE OR REPLACE FUNCTION types_plus.insert_inv_v2 (data_in types_plus.inv_v2[])  RETURNS intAS $BODY$ -- The CTE below is a roundabout way of returning an insertion count from a pure SQL function in Postgres.with inserted_rows as (        INSERT INTO inv (			id,			item_id,			item_arch_id,			facility_location_id,			standard_faclity_id,			store_at_facility_id,			created_dts,			updated_dts,			serial_no_as_of_dts,			qty,			flow,			flow_long,			par,			last_seen_date,			their_next_repair_date,			last_sterilized_date,			repair_last_repair_date,			is_searched_but_not_found,			marked_for_deletion,			is_found,			is_go_live_perm_printed,			is_sleeping,			is_handwritten_label,			is_wrong_loc,			is_facility_loc_inherited,			needs_repair,			is_deactivated,			is_contents_incomplete,			their_location,			category,			their_name,			their_id,			created_by,			updated_by,			their_id_scrubbed,			crossing_status,			inv_no,			their_raw_name,			comments_,			their_bar_code,			loc_rack,			loc_row,			loc_bin,			loc_note,			serial_no,			data_cleanse_classification,			repair_next_due,			repair_last_repaired_by,			msgs)                  SELECT			rows_in.id,			rows_in.item_id,			rows_in.item_arch_id,			rows_in.facility_location_id,			rows_in.standard_faclity_id,			rows_in.store_at_facility_id,			rows_in.created_dts,			rows_in.updated_dts,			rows_in.serial_no_as_of_dts,			rows_in.qty,			rows_in.flow,			rows_in.flow_long,			rows_in.par,			rows_in.last_seen_date,			rows_in.their_next_repair_date,			rows_in.last_sterilized_date,			rows_in.repair_last_repair_date,			rows_in.is_searched_but_not_found,			rows_in.marked_for_deletion,			rows_in.is_found,			rows_in.is_go_live_perm_printed,			rows_in.is_sleeping,			rows_in.is_handwritten_label,			rows_in.is_wrong_loc,			rows_in.is_facility_loc_inherited,			rows_in.needs_repair,			rows_in.is_deactivated,			rows_in.is_contents_incomplete,			rows_in.their_location,			rows_in.category,			rows_in.their_name,			rows_in.their_id,			rows_in.created_by,			rows_in.updated_by,			rows_in.their_id_scrubbed,			rows_in.crossing_status,			rows_in.inv_no,			rows_in.their_raw_name,			rows_in.comments_,			rows_in.their_bar_code,			rows_in.loc_rack,			rows_in.loc_row,			rows_in.loc_bin,			rows_in.loc_note,			rows_in.serial_no,			rows_in.data_cleanse_classification,			rows_in.repair_next_due,			rows_in.repair_last_repaired_by,			rows_in.msgs                      FROM unnest(data_in) as rows_in                  ON CONFLICT(id) DO UPDATE SET			item_id = EXCLUDED.item_id,			item_arch_id = EXCLUDED.item_arch_id,			facility_location_id = EXCLUDED.facility_location_id,			standard_faclity_id = EXCLUDED.standard_faclity_id,			store_at_facility_id = EXCLUDED.store_at_facility_id,			created_dts = EXCLUDED.created_dts,			updated_dts = EXCLUDED.updated_dts,			serial_no_as_of_dts = EXCLUDED.serial_no_as_of_dts,			qty = EXCLUDED.qty,			flow = EXCLUDED.flow,			flow_long = EXCLUDED.flow_long,			par = EXCLUDED.par,			last_seen_date = EXCLUDED.last_seen_date,			their_next_repair_date = EXCLUDED.their_next_repair_date,			last_sterilized_date = EXCLUDED.last_sterilized_date,			repair_last_repair_date = EXCLUDED.repair_last_repair_date,			is_searched_but_not_found = EXCLUDED.is_searched_but_not_found,			marked_for_deletion = EXCLUDED.marked_for_deletion,			is_found = EXCLUDED.is_found,			is_go_live_perm_printed = EXCLUDED.is_go_live_perm_printed,			is_sleeping = EXCLUDED.is_sleeping,			is_handwritten_label = EXCLUDED.is_handwritten_label,			is_wrong_loc = EXCLUDED.is_wrong_loc,			is_facility_loc_inherited = EXCLUDED.is_facility_loc_inherited,			needs_repair = EXCLUDED.needs_repair,			is_deactivated = EXCLUDED.is_deactivated,			is_contents_incomplete = EXCLUDED.is_contents_incomplete,			their_location = EXCLUDED.their_location,			category = EXCLUDED.category,			their_name = EXCLUDED.their_name,			their_id = EXCLUDED.their_id,			created_by = EXCLUDED.created_by,			updated_by = EXCLUDED.updated_by,			their_id_scrubbed = EXCLUDED.their_id_scrubbed,			crossing_status = EXCLUDED.crossing_status,			inv_no = EXCLUDED.inv_no,			their_raw_name = EXCLUDED.their_raw_name,			comments_ = EXCLUDED.comments_,			their_bar_code = EXCLUDED.their_bar_code,			loc_rack = EXCLUDED.loc_rack,			loc_row = EXCLUDED.loc_row,			loc_bin = EXCLUDED.loc_bin,			loc_note = EXCLUDED.loc_note,			serial_no = EXCLUDED.serial_no,			data_cleanse_classification = EXCLUDED.data_cleanse_classification,			repair_next_due = EXCLUDED.repair_next_due,			repair_last_repaired_by = EXCLUDED.repair_last_repaired_by,			msgs = EXCLUDED.msgs          returning 1 as row_counter)         select sum(row_counter)::integer from inserted_rows; $BODY$LANGUAGE sql;  ALTER FUNCTION types_plus.insert_inv_v2(types_plus.inv_v2[])	OWNER TO user_bender;