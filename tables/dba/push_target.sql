-------------------------------------- Define table------------------------------------BEGIN;DROP TABLE IF EXISTS dba.push_target CASCADE;CREATE TABLE IF NOT EXISTS dba.push_target (    id                int8       GENERATED ALWAYS AS IDENTITY PRIMARY KEY,    unique_path       citext     NOT NULL DEFAULT NULL UNIQUE,    schema_name       citext     NOT NULL DEFAULT NULL,    target_name       citext     NOT NULL DEFAULT NULL,    qualified_name    citext     GENERATED ALWAYS AS (schema_name || '.' || target_name) STORED, -- Qualified name for tables, not for passthroughs.    target_type       citext     NOT NULL DEFAULT NULL);ALTER TABLE dba.push_target	OWNER TO user_change_structure;COMMENT ON TABLE dba.push_target IS'Server-side table to consolidate target strings, linked back to push_audit logs by a server-side integer key. Not directly pushed from IB/Sonar. All INSERTs on this table come from the insert-handling Postgres functions for push_audit.';-------------------------------------- Build statistics------------------------------------/*The Postgres ANALYZE system function collects statistics about each table and column. These valuesare used by the query planner to help generate probabilistic cost estimates for various query plans.When the plans are based on misleading stats, you can have poor performance. Stats can be reconfiguredon a row-by-row basis, and some special extended statistics are supported too.Custom and extended statistics are typically added after we've been accumulating data for some time.See PgBuildStatistics_Extended in IB to declare new statistics objects. For more background, seehttps://ascendco.atlassian.net/wiki/spaces/SON/pages/1723695105/*/-------------------------------------- ANALYZE options-------------------------------------- Placholder and reminder for now. ANALYZE and AUTOVACUUM tunings are *core* Postgres DBA-- skills. But, for the minute, we're not running into trouble. I'm chipping away af figuring-- out when to tune, and how, and when not to tune. ‚Äî DPA-------------------------------------- Build indexes-------------------------------------- Note: Postgres automatically creates a UNIQUE B-tree for the PRIMARY KEY, simple or compound.-- Note: Postgres automatically creates a UNIQUE B-tree for columns marked UNIQUE.-------------------------------------- CLUSTER------------------------------------/*Code stub/reminder about CLUSTERing. Not a hard topic, but too big to write up here. Notes and links:https://ascendco.atlassian.net/wiki/spaces/SON/pages/356679683/ALTER TABLE dba.push_target    CLUSTER ON ***index name to cluster by here;*/-------------------------------------- Add triggers------------------------------------   CREATE TRIGGER trigger_push_target_after_delete            AFTER DELETE               ON dba.push_target      REFERENCING OLD TABLE AS deleted_rows         FOR EACH STATEMENTEXECUTE PROCEDURE ascendco.trigger_function_log_deletion_count();  CREATE TRIGGER trigger_push_target_before_truncate            BEFORE TRUNCATE               ON dba.push_target         FOR EACH STATEMENTEXECUTE PROCEDURE ascendco.trigger_function_log_truncation_count();-------------------------------------- Manual Permissions for now-------------------------------------- Standard permissions for utility/admin users:GRANT SELECT, INSERT, UPDATE, DELETE ON dba.push_target TO rds_super;GRANT SELECT, INSERT, UPDATE, DELETE ON dba.push_target TO user_cleanup;GRANT SELECT, INSERT, UPDATE ON dba.push_target TO user_reporting;GRANT SELECT, INSERT, UPDATE ON dba.push_target TO user_change_structure;-- Adjustable user permissions:GRANT SELECT, INSERT, UPDATE ON dba.push_target TO user_iceberg;GRANT SELECT, INSERT, UPDATE ON dba.push_target TO user_iceberg_remote;GRANT SELECT, INSERT, UPDATE ON dba.push_target TO user_saws;GRANT SELECT, INSERT, UPDATE ON dba.push_target TO user_sonar;GRANT SELECT, INSERT, UPDATE ON dba.push_target TO user_leviathan;COMMIT;