-------------------------------------- Define table------------------------------------BEGIN;DROP TABLE IF EXISTS dba.target_count CASCADE;-- Why the peculiar column order? column_tetris('target_count').-- https://ascendco.atlassian.net/wiki/spaces/SON/pages/666501123/Arranging+Fields+to+Optimize+Disk+Space-- This is a potentially large table, and worth some fuss to make more efficient.CREATE TABLE IF NOT EXISTS dba.target_count (    hsys_id              uuid         NOT NULL DEFAULT NULL,    records_count        int4         NOT NULL DEFAULT 0,    count_date           date         NOT NULL DEFAULT current_date,    count_dts            timestamp    NOT NULL DEFAULT now(),    qualified_name       citext       NOT NULL DEFAULT NULL);ALTER TABLE dba.target_count ADD CONSTRAINT   target_count_pk   PRIMARY KEY (hsys_id, qualified_name, count_date);ALTER TABLE dba.target_count	OWNER TO user_change_structure;-------------------------------------- Build statistics------------------------------------/*The Postgres ANALYZE system function collects statistics about each table and column. These valuesare used by the query planner to help generate probabilistic cost estimates for various query plans.When the plans are based on misleading stats, you can have poor performance. Stats can be reconfiguredon a row-by-row basis, and some special extended statistics are supported too.Custom and extended statistics are typically added after we've been accumulating data for some time.See PgBuildStatistics_Extended in IB to declare new statistics objects. For more background, seehttps://ascendco.atlassian.net/wiki/spaces/SON/pages/1723695105/*/-------------------------------------- ANALYZE options-------------------------------------- Placholder and reminder for now. ANALYZE and AUTOVACUUM tunings are *core* Postgres DBA-- skills. But, for the minute, we're not running into trouble. I'm chipping away af figuring-- out when to tune, and how, and when not to tune. ‚Äî DPA-------------------------------------- Build indexes-------------------------------------- Note: Postgres automatically creates a UNIQUE B-tree for the PRIMARY KEY, simple or compound.-------------------------------------- CLUSTER------------------------------------/*Code stub/reminder about CLUSTERing. Not a hard topic, but too big to write up here. Notes and links:https://ascendco.atlassian.net/wiki/spaces/SON/pages/356679683/ALTER TABLE dba.target_count    CLUSTER ON ***index name to cluster by here;*/-------------------------------------- Add triggers-------------------------------------- None for now.-------------------------------------- Manual Permissions for now-------------------------------------- Standard permissions for utility/admin users:GRANT SELECT, INSERT, UPDATE, DELETE ON dba.target_count TO rds_super;GRANT SELECT, INSERT, UPDATE, DELETE ON dba.target_count TO user_cleanup;GRANT SELECT, INSERT, UPDATE, DELETE ON dba.target_count TO user_reporting;GRANT SELECT ON dba.target_count TO user_change_structure;-- Adjustable user permissions:GRANT SELECT ON dba.target_count TO user_iceberg;GRANT SELECT ON dba.target_count TO user_iceberg_remote;GRANT SELECT ON dba.target_count TO user_saws;GRANT SELECT ON dba.target_count TO user_sonar;GRANT SELECT, INSERT, UPDATE, DELETE ON dba.target_count TO user_leviathan;COMMIT;