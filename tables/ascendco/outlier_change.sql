-------------------------------------- Define table------------------------------------BEGIN;DROP TABLE IF EXISTS ascendco.outlier_change CASCADE;CREATE TABLE IF NOT EXISTS ascendco.outlier_change (	id uuid NOT NULL DEFAULT NULL,	outlier_rule_id uuid NOT NULL DEFAULT NULL,	value_was bigint NOT NULL DEFAULT NULL,	set_to bigint NOT NULL DEFAULT NULL,	change_count bigint NOT NULL DEFAULT 0,	last_changed_dts timestamptz NOT NULL DEFAULT NOW());ALTER TABLE ascendco.outlier_change	ADD CONSTRAINT outlier_change_pkey    PRIMARY KEY (id, outlier_rule_id);/*ALTER TABLE ascendco.outlier_change	ADD CONSTRAINT outlier_rule_fkey	FOREIGN KEY (outlier_rule_id)	REFERENCES ascendco.outlier_rule (id)	ON DELETE CASCADE	ON UPDATE NO ACTION;*/ALTER TABLE ascendco.outlier_change	OWNER TO user_change_structure;COMMIT;-------------------------------------- Build indexes-------------------------------------- Nope. Postgres won't even bother with an index for searches on such a tiny table.-- Note: You always need an index for a unique constraint. PG defines that automatically for the PRIMARY.-- Note: If this table gets bigger, and we search on it, we may find we can use an index.-------------------------------------- Trigger function-------------------------------------- Function defined here as the function isn't used elsewhere:CREATE OR REPLACE FUNCTION ascendco.trigger_function_outlier_upsert()  RETURNS triggerAS $BODY$BEGIN    NEW.last_changed_dts := NOW();	NEW.change_count     := COALESCE(OLD.change_count,0) + 1;    RETURN NEW;    		 -- important!END;$BODY$	LANGUAGE plpgsql VOLATILE	COST 100;ALTER FUNCTION ascendco.trigger_function_outlier_upsert	OWNER TO user_bender;-------------------------------------- Add triggers------------------------------------CREATE TRIGGER trigger_outlier_change_before_upsert	BEFORE INSERT OR UPDATE	ON ascendco.outlier_change	FOR EACH ROW	EXECUTE PROCEDURE ascendco.trigger_function_outlier_upsert();