-- The table/join aliases are important here.-- ap          = analytic_productivity-- start_local = calendar_date, as joined on analytic_productivity.start_local-- end_local   = calendar_date, as joined on analytic_productivity.end_lcoal   select -- First up, some fields from the main analytic table.          ap.user_name,          ap.num_inst,          ap.assembly_minutes,          ap.pause_minutes,         -- Next, some fields from the date record matching analytic_productivity.start_local.          start_local.year_actual,          start_local.week_of_year_iso,         -- Fially, some fields from the date record matching analytic_productivity.end_lcoal.          end_local.year_actual,          end_local.week_of_year_iso        -- You can mix, match, combine, calculate, etc. however you like, from all of the tables/products./*These next two joins look more complicated than they are because of the concatenated key.What you've got here are two prodcuts, or "result sets." These are in-memory mini-tablesthat survive for the life of the query. "s1" holds the full calendar_date record matchingthe data found in analytic_productivity.start_local. Likewise, "end_local" holds the recordin calendar_date matching analytic_productivity.end_lcoal. You can pull out whatever fieldsyou need in the SELECT list above without having to write any extra queries, etc.There are maybe 5 fundamental bits of genius in SQL. This is likely #1 on the list.Getting JOIN to work properly took decades.*/     from analytic_productivity AS apleft join calendar_date start_local           ON start_local.calendar_date_id = '3bd53332-3d4e-4085-afd3-691bd057e5a5' || TO_CHAR(ap.start_local, 'yyyymmdd')::INTleft join calendar_date end_local           ON start_local.calendar_date_id = '3bd53332-3d4e-4085-afd3-691bd057e5a5' || TO_CHAR(ap.end_local, 'yyyymmdd')::INTwhere assembly_minutes <=20 and num_inst >= 100limit 20