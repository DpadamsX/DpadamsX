------------------------------------------------------------------------------------- Checks for types_plus.insert_text_collection_v1 (data_in text_text[], mark_for_retention_in boolean, facility_id_in uuid, collection_name_in citext) function------------------------------------------------------------------------------------- Existence check:select * from test_case_setup('Function', 'types_plus', 'insert_text_collection_v1 (data_in text_text[], mark_for_retention_in boolean, facility_id_in uuid, collection_name_in citext)', '()', 'types_plus.insert_text_collection_v1 data_in text_text[], mark_for_retention_in boolean, facility_id_in uuid, collection_name_in citext existence check', 'select count(*) from pg_proc where pronamespace::regnamespace::text = ''types_plus''   and proname = ''insert_text_collection_v1''   and pg_get_function_identity_arguments(oid) = ''data_in text_text[], mark_for_retention_in boolean, facility_id_in uuid, collection_name_in citext'';', '1', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');-- Definition check:select * from test_case_setup('Function', 'types_plus', 'insert_text_collection_v1 (data_in text_text[], mark_for_retention_in boolean, facility_id_in uuid, collection_name_in citext)', '()', 'types_plus.insert_text_collection_v1 data_in text_text[], mark_for_retention_in boolean, facility_id_in uuid, collection_name_in citext definition check', 'select pg_get_functiondef(oid) from pg_proc where pronamespace::regnamespace::text = ''types_plus''   and proname = ''insert_text_collection_v1''   and pg_get_function_identity_arguments(oid) = ''data_in text_text[], mark_for_retention_in boolean, facility_id_in uuid, collection_name_in citext'';', 'CREATE OR REPLACE FUNCTION types_plus.insert_text_collection_v1(data_in text_text[], mark_for_retention_in boolean DEFAULT false, facility_id_in uuid DEFAULT ''00000000-0000-0000-0000-000000000000''::uuid, collection_name_in citext DEFAULT ''''::citext) RETURNS uuid LANGUAGE sqlAS $function$-- First, add the new collection and get back its ID for use in the rest of the script.WITH new_collection AS (  INSERT INTO text_collection (              retain,              facility_id,              collection_name)    VALUES (mark_for_retention_in,            facility_id_in,            collection_name_in)-- Note: ON CONFLICT on a partial index requires the WHERE clause to be repeated here in ON CONFLICT.ON CONFLICT (collection_name) WHERE collection_name <> '''' DO UPDATE SET            retain      = EXCLUDED.retain,            facility_id = EXCLUDED.facility_idRETURNING id)-- Now, unpack the incoming array of strings, and insert each one into-- text_collectoin_item, along with the ID of the text_collection just created.INSERT INTO text_collection_item (   	   collection_id,       text,       source_id)SELECT DISTINCT ON (rows_in.text)      new_collection.id,      rows_in.text,      rows_in.id FROM new_collection,      unnest(data_in) as rows_in -- Silently remove duplicate strings from the list. ON CONFLICT (collection_id, text) DO UPDATE SET      source_id = EXCLUDED.source_id-- Everything is done, return the new collection''s ID to the client. -- RETURNING is a *very* cool Postgres extension to standard SQL. -- Earlier, we used it to get the new ID out of the CTE for reuse -- by the main query. Now, we''re returning that ID to the client -- for whatever purpose they have.RETURNING collection_id;$function$', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');