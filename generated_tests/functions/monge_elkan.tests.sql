------------------------------------------------------------------------------------- Checks for tools.monge_elkan (base_text text, comparison_text text, distance_measure_name text, handicap boolean, lexize_strings boolean) function------------------------------------------------------------------------------------- Existence check:select * from test_case_setup('Function', 'tools', 'monge_elkan (base_text text, comparison_text text, distance_measure_name text, handicap boolean, lexize_strings boolean)', '()', 'tools.monge_elkan base_text text, comparison_text text, distance_measure_name text, handicap boolean, lexize_strings boolean existence check', 'select count(*) from pg_proc where pronamespace::regnamespace::text = ''tools''   and proname = ''monge_elkan''   and pg_get_function_identity_arguments(oid) = ''base_text text, comparison_text text, distance_measure_name text, handicap boolean, lexize_strings boolean'';', '1', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');-- Definition check:select * from test_case_setup('Function', 'tools', 'monge_elkan (base_text text, comparison_text text, distance_measure_name text, handicap boolean, lexize_strings boolean)', '()', 'tools.monge_elkan base_text text, comparison_text text, distance_measure_name text, handicap boolean, lexize_strings boolean definition check', 'select pg_get_functiondef(oid) from pg_proc where pronamespace::regnamespace::text = ''tools''   and proname = ''monge_elkan''   and pg_get_function_identity_arguments(oid) = ''base_text text, comparison_text text, distance_measure_name text, handicap boolean, lexize_strings boolean'';', 'CREATE OR REPLACE FUNCTION tools.monge_elkan(base_text text, comparison_text text, distance_measure_name text DEFAULT ''jarowinkler''::text, handicap boolean DEFAULT true, lexize_strings boolean DEFAULT false) RETURNS real LANGUAGE plpgsql STABLEAS $function$DECLARE  base_word                 text;  comparison_word           text;  score                     float8;  best_score                float8;  best_scores_sum           float8;  monge_elkan_score         real;  base_words_count          int4;  comparison_words_count    float8;  word_count_ratio          float8;  base_words_array          text[];  comparison_words_array    text[];BEGIN    distance_measure_name  := lower(distance_measure_name);	IF distance_measure_name NOT IN (''qgram'',''jaro'',''jarowinkler'') THEN		RAISE EXCEPTION USING			message = ''Invalid distance measure name '''''' || distance_measure_name || '''''''',			hint = ''Valid methods are jaro, jarowinkler, and qgram'',			errcode = ''KC100''; -- Custom code for ''Bad string selector parameter value''.		RETURN -1;	END IF;    base_text       := lower(base_text);    comparison_text := lower(comparison_text);    IF lexize_strings = true THEN		select into base_words_array		            array_agg(word)			   from ts_stat(''SELECT to_tsvector(''''english'''',quote_literal(base_text))'');			select into comparison_words_array		            array_agg(word)			   from ts_stat(''SELECT to_tsvector(''''english'''',quote_literal(comparison_text))'');    ELSE		select into base_words_array			string_to_array(base_text, '' '');		select into comparison_words_array			string_to_array (comparison_text, '' '');	END IF;	base_words_count  := 0;	best_scores_sum   := 0;    monge_elkan_score := 0;	FOREACH base_word IN array base_words_array LOOP		base_words_count := base_words_count + 1; -- PL/PgSQL doesn''t have ++. Who does that? ;-)		best_score:=0;   -- Eh? Why repeat the loop. Micro-optimization, or better.	 -- This way, the which-method-to-use test runs once, not once per loop.		IF distance_measure_name = ''jaro'' THEN				FOREACH comparison_word IN array comparison_words_array LOOP							 score      := jaro (base_word, comparison_word);							 best_score := greatest(score, best_score);				END LOOP;	    ELSEIF distance_measure_name = ''jarowinkler'' THEN				FOREACH comparison_word IN array comparison_words_array LOOP							 score      := jarowinkler (base_word, comparison_word);							 best_score := greatest(score, best_score);				END LOOP;		  ELSEIF distance_measure_name = ''qgram'' THEN				FOREACH comparison_word IN array comparison_words_array LOOP							 score      := qgram (base_word, comparison_word);							 best_score := greatest(score, best_score);				END LOOP;			ELSE				RAISE EXCEPTION USING					message = ''Invalid distance measure name '''''' || distance_measure_name || '''''''',					hint = ''Valid methods are jaro, jarowinkler, and qgram. Problem should have been caught earlier.'',					errcode = ''KC100''; -- Custom code for ''Bad string selector parameter value''.		END IF;		best_scores_sum := 	best_scores_sum + best_score;	END LOOP;   comparison_words_count := array_length(comparison_words_array, 1);       -- Being very explicit here about avoiding zero division.   	IF base_words_count = 0 THEN		word_count_ratio := 0;	ELSEIF comparison_words_count = 0 THEN		word_count_ratio := 0;    ELSE        word_count_ratio := (base_words_count / comparison_words_count)::real;   END IF;    -- Being very explicit here about avoiding zero division.	IF best_scores_sum = 0 THEN		monge_elkan_score := 0;	ELSEIF base_words_count = 0 THEN		monge_elkan_score := 0;	ELSEIF comparison_words_count = 0 THEN		monge_elkan_score := 0;    ELSE		monge_elkan_score:= (best_scores_sum / base_words_count)::real;		IF handicap = true AND word_count_ratio <= .67 THEN		     monge_elkan_score := monge_elkan_score - 0.1;		END IF;    END IF;	RETURN monge_elkan_score;END$function$', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');