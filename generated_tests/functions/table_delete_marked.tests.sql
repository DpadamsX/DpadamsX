------------------------------------------------------------------------------------- Checks for ascendco.table_delete_marked (table_name regclass, OUT deleted_count integer) function------------------------------------------------------------------------------------- Existence check:select * from test_case_setup('Function', 'ascendco', 'table_delete_marked (table_name regclass, OUT deleted_count integer)', '()', 'ascendco.table_delete_marked table_name regclass, OUT deleted_count integer existence check', 'select count(*) from pg_proc where pronamespace::regnamespace::text = ''ascendco''   and proname = ''table_delete_marked''   and pg_get_function_identity_arguments(oid) = ''table_name regclass, OUT deleted_count integer'';', '1', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');-- Definition check:select * from test_case_setup('Function', 'ascendco', 'table_delete_marked (table_name regclass, OUT deleted_count integer)', '()', 'ascendco.table_delete_marked table_name regclass, OUT deleted_count integer definition check', 'select pg_get_functiondef(oid) from pg_proc where pronamespace::regnamespace::text = ''ascendco''   and proname = ''table_delete_marked''   and pg_get_function_identity_arguments(oid) = ''table_name regclass, OUT deleted_count integer'';', 'CREATE OR REPLACE FUNCTION ascendco.table_delete_marked(table_name regclass, OUT deleted_count integer) RETURNS integer LANGUAGE plpgsqlAS $function$DECLARE	schema_name_text text := (select relnamespace::regnamespace::text							from pg_catalog.pg_class						   where oid = table_name);   table_name_text  text := table_name::text;BEGIN/* Woah! What''s happening? EXECUTE? Yes, concatenation is safe here because table_nameis ::regclass, not text. The regclass magic type is designed to be injection proof.For more involved work, see format(), quote_ident(), and commentary/docs on dynamic SQLgenerally. It''s all be thought through well. Also seehttps://ascendco.atlassian.net/wiki/spaces/SON/pages/767459342/Deleting+Records+on+Postgres*/	EXECUTE ''delete from '' || schema_name_text || ''.'' || table_name_text || '' where marked_for_deletion = true;'';	GET DIAGNOSTICS deleted_count = ROW_COUNT;END;$function$', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');