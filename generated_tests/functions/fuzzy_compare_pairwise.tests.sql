------------------------------------------------------------------------------------- Checks for tools.fuzzy_compare_pairwise (base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real, monge_elkan_similarity_method_in citext) function------------------------------------------------------------------------------------- Existence check:select * from test_case_setup('Function', 'tools', 'fuzzy_compare_pairwise (base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real, monge_elkan_similarity_method_in citext)', '()', 'tools.fuzzy_compare_pairwise base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real, monge_elkan_similarity_method_in citext existence check', 'select count(*) from pg_proc where pronamespace::regnamespace::text = ''tools''   and proname = ''fuzzy_compare_pairwise''   and pg_get_function_identity_arguments(oid) = ''base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real, monge_elkan_similarity_method_in citext'';', '1', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');-- Definition check:select * from test_case_setup('Function', 'tools', 'fuzzy_compare_pairwise (base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real, monge_elkan_similarity_method_in citext)', '()', 'tools.fuzzy_compare_pairwise base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real, monge_elkan_similarity_method_in citext definition check', 'select pg_get_functiondef(oid) from pg_proc where pronamespace::regnamespace::text = ''tools''   and proname = ''fuzzy_compare_pairwise''   and pg_get_function_identity_arguments(oid) = ''base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real, monge_elkan_similarity_method_in citext'';', 'CREATE OR REPLACE FUNCTION tools.fuzzy_compare_pairwise(base_jsonb_in jsonb, comparison_jsonb_in jsonb, handicap_factor_in real DEFAULT 0.3, monge_elkan_similarity_method_in citext DEFAULT ''jarowinkler''::citext) RETURNS TABLE(base_text citext, comparison_text citext, base_id citext, comparison_id citext, highest_score decimal_score, best_method citext, avg_score decimal_score, avg_quadratic_score decimal_score, lowest_score decimal_score, equality_check integer, jaro_score decimal_score, jaro_winkler_score decimal_score, levenshtein_score decimal_score, monge_elkan_score decimal_score, monge_elkan_quadratic_score decimal_score, monge_elkan_handicap_score decimal_score, monge_elkan_quadratic_handicap_score decimal_score, qgram_score decimal_score, trigram_score decimal_score) LANGUAGE plpgsqlAS $function$BEGIN-------------------------------------------------------------- Safety checks for parameters stitched into the SQL.------------------------------------------------------------    monge_elkan_similarity_method_in  := lower(monge_elkan_similarity_method_in);    IF monge_elkan_similarity_method_in NOT IN (''jaro'',''jarowinkler'',''qgram'') THEN        RAISE EXCEPTION USING            message = ''Invalid distance measure name '' || monge_elkan_similarity_method_in,            hint = ''Valid methods are jaro, jarowinkler, and qgram'',            errcode = ''KC300''; -- Custom code for ''Bad lookup ID''.    END IF;-------------------------------------------------------------- Range/sanity checks on thresholds------------------------------------------------------------    IF handicap_factor_in < 0 OR handicap_factor_in > 1 THEN        RAISE EXCEPTION USING            message = ''handicap_factor value is out of range.'',            hint = ''Value must be in the range 0-1.'',            errcode = ''KC202''; -- Custom code for ''Numeric parameter value is too low''.    END IF;RETURN QUERYWITHbase_expanded AS (   SELECT * FROM jsonb_array_elements(base_jsonb_in::jsonb)       WITH ORDINALITY AS x(element, idx)),comparison_expanded AS (   SELECT * FROM jsonb_array_elements(comparison_jsonb_in::jsonb)       WITH ORDINALITY AS y(element, idx) ),-- Pairwise JOIN using ordinality-geneated index as the joining term.-- So, base element 1 to comaprison element 1, and so on.combined_lists AS (select base_expanded.element ->> ''text''        AS base_text_x,       base_expanded.element ->> ''id''          AS base_id_x,       comparison_expanded.element ->> ''text''  AS comparison_text_x,       comparison_expanded.element ->> ''id''    AS comparison_id_x  from base_expanded  join comparison_expanded ON (comparison_expanded.idx = base_expanded.idx)),---------------------------------------------------------- Pull in the basic scores, and add some handicaps--------------------------------------------------------basic_scores AS (select base_text_x,       comparison_text_x,       base_id_x,       comparison_id_x,       (base_text_x = comparison_text_x)::int4                                              AS equality_check_x,       monge_elkan(base_text_x, comparison_text_x,monge_elkan_similarity_method_in)         AS monge_elkan_score_x,       sqrt(monge_elkan(base_text_x, comparison_text_x, monge_elkan_similarity_method_in))  AS monge_elkan_quadratic_score_x,       jaccard(base_text_x,comparison_text_x)                                               AS jaccard_coefficient,       jaccard(base_text_x,comparison_text_x) * handicap_factor_in                          AS jaccard_handicap,       qgram(base_text_x,comparison_text_x)                                                 AS qgram_score_x,       similarity(base_text_x,comparison_text_x)                                            AS trigram_score_x,       lev(base_text_x,comparison_text_x)                                                   AS levenshtein_score_x,       jaro(base_text_x,comparison_text_x)                                                  AS jaro_score_x,       jarowinkler(base_text_x,comparison_text_x)                                           AS jaro_winkler_score_x  from combined_lists),---------------------------------------------------------- Pull in the basic scores, and add some handicaps--------------------------------------------------------extended_scores AS (SELECT  base_text_x,        comparison_text_x,        base_id_x,        comparison_id_x,        equality_check_x,        jaro_score_x::decimal_score,        jaro_winkler_score_x::decimal_score,        levenshtein_score_x::decimal_score,        monge_elkan_score_x::decimal_score,        monge_elkan_quadratic_score_x::decimal_score,        (monge_elkan_score_x - jaccard_handicap)::decimal_score AS monge_elkan_handicap_score_x,        (monge_elkan_quadratic_score_x - jaccard_handicap)::decimal_score AS monge_elkan_quadratic_handicap_score_x,        jaccard_coefficient,        jaccard_handicap,        qgram_score_x::decimal_score,        trigram_score_x::decimal_score  FROM basic_scores),---------------------------------------------------------- Augment with overall stats on range of scores--------------------------------------------------------  score_stats AS (  SELECT base_text_x,         comparison_text_x,         base_id_x,         comparison_id_x,         equality_check_x,         jaro_score_x,         jaro_winkler_score_x,         levenshtein_score_x,         monge_elkan_score_x,         monge_elkan_quadratic_score_x,         monge_elkan_handicap_score_x,         monge_elkan_quadratic_handicap_score_x,         jaccard_coefficient,         jaccard_handicap,         qgram_score_x,         trigram_score_x,           GREATEST (           equality_check_x,           jaro_score_x,           jaro_winkler_score_x,           levenshtein_score_x,           monge_elkan_score_x,           monge_elkan_handicap_score_x,           monge_elkan_quadratic_score_x,           monge_elkan_quadratic_handicap_score_x,           qgram_score_x,           trigram_score_x)::decimal_score AS highest_score_x,-- Leave out equality_check_x out of LEAST and AVG scores. It''s either 0 or 1, almost always 0.        LEAST (           jaro_score_x,           jaro_winkler_score_x,           levenshtein_score_x,           monge_elkan_score_x,           monge_elkan_handicap_score_x,           monge_elkan_quadratic_score_x,           monge_elkan_quadratic_handicap_score_x,           qgram_score_x,           trigram_score_x)::decimal_score AS lowest_score_x,         ((jaro_score_x +           jaro_winkler_score_x +           levenshtein_score_x +           monge_elkan_score_x +           monge_elkan_handicap_score_x +           monge_elkan_quadratic_score_x +           monge_elkan_quadratic_handicap_score_x +           qgram_score_x +           trigram_score_x) / 10)::decimal_score AS avg_score_x,           sqrt((jaro_score_x +           jaro_winkler_score_x +           levenshtein_score_x +           monge_elkan_score_x +           monge_elkan_handicap_score_x +           monge_elkan_quadratic_score_x +           monge_elkan_quadratic_handicap_score_x +           qgram_score_x +           trigram_score_x) / 10)::decimal_score AS avg_quadratic_score_x     FROM extended_scores        )---------------------------------------------------------- Final result: Get everything, along with the top score--------------------------------------------------------SELECT base_text_x::citext,       comparison_text_x::citext,       base_id_x::citext,       comparison_id_x::citext,       highest_score_x,        -- Ugh. Researching better methods for doing this part...and some of the others...bit too long.        -- In case of a tie, this code picks the first match.       CASE          WHEN highest_score_x = 0 THEN ''none''          WHEN highest_score_x = equality_check_x                       THEN ''equality_check''          WHEN highest_score_x = monge_elkan_score_x                    THEN ''monge_elkan''          WHEN highest_score_x = monge_elkan_handicap_score_x           THEN ''monge_elkan_handicap''          WHEN highest_score_x = monge_elkan_quadratic_score_x          THEN ''monge_elkan_quadratic''          WHEN highest_score_x = monge_elkan_quadratic_handicap_score_x THEN ''monge_elkan_quadratic_handicap''          WHEN highest_score_x = qgram_score_x                          THEN ''qgram''          WHEN highest_score_x = trigram_score_x                        THEN ''trigram''          WHEN highest_score_x = levenshtein_score_x                    THEN ''levenshtein''          WHEN highest_score_x = jaro_score_x                           THEN ''jaro''          WHEN highest_score_x = jaro_winkler_score_x                   THEN ''jaro_winkler''          WHEN highest_score_x = avg_score_x                            THEN ''avg''          WHEN highest_score_x = avg_quadratic_score_x                  THEN ''avg_quadratic''          ELSE ''Undefined''::citext        END AS best_method_x,       avg_score_x,       avg_quadratic_score_x,       lowest_score_x,       equality_check_x,       jaro_score_x,       jaro_winkler_score_x,       levenshtein_score_x,       monge_elkan_score_x,       monge_elkan_quadratic_score_x,       monge_elkan_handicap_score_x,       monge_elkan_quadratic_handicap_score_x,       qgram_score_x,       trigram_score_x  FROM score_stats;END$function$', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');