------------------------------------------------------------------------------------- Checks for tools.fuzzy_compare (base_text_in citext, comparison_text_in citext, base_id_in citext, comparison_id_in citext, handicap_factor_in real, monge_elkan_similarity_method_in citext) function------------------------------------------------------------------------------------- Existence check:select * from test_case_setup('Function', 'tools', 'fuzzy_compare (base_text_in citext, comparison_text_in citext, base_id_in citext, comparison_id_in citext, handicap_factor_in real, monge_elkan_similarity_method_in citext)', '()', 'tools.fuzzy_compare base_text_in citext, comparison_text_in citext, base_id_in citext, comparison_id_in citext, handicap_factor_in real, monge_elkan_similarity_method_in citext existence check', 'select count(*) from pg_proc where pronamespace::regnamespace::text = ''tools''   and proname = ''fuzzy_compare''   and pg_get_function_identity_arguments(oid) = ''base_text_in citext, comparison_text_in citext, base_id_in citext, comparison_id_in citext, handicap_factor_in real, monge_elkan_similarity_method_in citext'';', '1', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');-- Definition check:select * from test_case_setup('Function', 'tools', 'fuzzy_compare (base_text_in citext, comparison_text_in citext, base_id_in citext, comparison_id_in citext, handicap_factor_in real, monge_elkan_similarity_method_in citext)', '()', 'tools.fuzzy_compare base_text_in citext, comparison_text_in citext, base_id_in citext, comparison_id_in citext, handicap_factor_in real, monge_elkan_similarity_method_in citext definition check', 'select pg_get_functiondef(oid) from pg_proc where pronamespace::regnamespace::text = ''tools''   and proname = ''fuzzy_compare''   and pg_get_function_identity_arguments(oid) = ''base_text_in citext, comparison_text_in citext, base_id_in citext, comparison_id_in citext, handicap_factor_in real, monge_elkan_similarity_method_in citext'';', 'CREATE OR REPLACE FUNCTION tools.fuzzy_compare(base_text_in citext, comparison_text_in citext, base_id_in citext DEFAULT ''''::citext, comparison_id_in citext DEFAULT ''''::citext, handicap_factor_in real DEFAULT 0.3, monge_elkan_similarity_method_in citext DEFAULT ''jarowinkler''::citext) RETURNS TABLE(base_text citext, comparison_text citext, base_id citext, comparison_id citext, highest_score decimal_score, best_method citext, avg_score decimal_score, avg_quadratic_score decimal_score, lowest_score decimal_score, equality_check integer, jaro_score decimal_score, jaro_winkler_score decimal_score, levenshtein_score decimal_score, monge_elkan_score decimal_score, monge_elkan_quadratic_score decimal_score, monge_elkan_handicap_score decimal_score, monge_elkan_quadratic_handicap_score decimal_score, qgram_score decimal_score, trigram_score decimal_score) LANGUAGE plpgsqlAS $function$DECLARE-------------------------------------------------------------- Setup query template, which you can RAISE NOTICE while .-- developing to see what''s in it.------------------------------------------------------------sql text := ''WITHbasic_scores AS (  SELECT $1                           AS base_text,         $2                           AS comparison_text,         $3                           AS base_id,         $4                           AS comparison_id,         ($1 = $2)::int4              AS equality_check,         monge_elkan($1,$2,$6)        AS monge_elkan_score,         sqrt(monge_elkan($1,$2,$6))  AS monge_elkan_quadratic_score,         jaccard($1,$2)               AS jaccard_coefficient,         jaccard($1,$2) * $5          AS jaccard_handicap,         qgram($1,$2)                 AS qgram_score,         similarity($1,$2)            AS trigram_score,         word_similarity($1,$2)       AS word_score,         lev($1,$2)                   AS levenshtein_score,         jaro($1,$2)                  AS jaro_score,         jarowinkler($1,$2)           AS jaro_winkler_score),---------------------------------------------------------- Pull in the basic scores, and add some handicaps--------------------------------------------------------extended_scores AS (SELECT  base_text,        comparison_text,        base_id,        comparison_id,        equality_check,        jaro_score::decimal_score,        jaro_winkler_score::decimal_score,        levenshtein_score::decimal_score,        monge_elkan_score::decimal_score,        monge_elkan_quadratic_score::decimal_score,        (monge_elkan_score - jaccard_handicap)::decimal_score AS monge_elkan_handicap_score,        (monge_elkan_quadratic_score - jaccard_handicap)::decimal_score AS monge_elkan_quadratic_handicap_score,        jaccard_coefficient,        jaccard_handicap,        qgram_score::decimal_score,        trigram_score::decimal_score  FROM basic_scores),  score_stats AS (  SELECT GREATEST (           equality_check,           jaro_score,           jaro_winkler_score,           levenshtein_score,           monge_elkan_score,           monge_elkan_handicap_score,           monge_elkan_quadratic_score,           monge_elkan_quadratic_handicap_score,           qgram_score,           trigram_score)::decimal_score AS highest_score,-- Leave out equality_check out of LEAST and AVG scores. It''''s either 0 or 1, almost always 0.        LEAST (           jaro_score,           jaro_winkler_score,           levenshtein_score,           monge_elkan_score,           monge_elkan_handicap_score,           monge_elkan_quadratic_score,           monge_elkan_quadratic_handicap_score,           qgram_score,           trigram_score)::decimal_score AS lowest_score,         ((jaro_score +           jaro_winkler_score +           levenshtein_score +           monge_elkan_score +           monge_elkan_handicap_score +           monge_elkan_quadratic_score +           monge_elkan_quadratic_handicap_score +           qgram_score +           trigram_score) / 10)::decimal_score AS avg_score,          sqrt((jaro_score +           jaro_winkler_score +           levenshtein_score +           monge_elkan_score +           monge_elkan_handicap_score +           monge_elkan_quadratic_score +           monge_elkan_quadratic_handicap_score +           qgram_score +           trigram_score ) / 10)::decimal_score AS avg_quadratic_score     FROM extended_scores        )---------------------------------------------------------- Final result: Get everything, along with the top score--------------------------------------------------------SELECT extended_scores.base_text,       extended_scores.comparison_text,       extended_scores.base_id,       extended_scores.comparison_id,       score_stats.highest_score,        -- Ugh. Researching better methods for doing this part...and some of the others...bit too long.        -- In case of a tie, this code picks the first match.       CASE          WHEN score_stats.highest_score = 0 THEN ''''none''''          WHEN score_stats.highest_score = equality_check THEN ''''equality_check''''          WHEN score_stats.highest_score = extended_scores.monge_elkan_score THEN ''''monge_elkan''''          WHEN score_stats.highest_score = extended_scores.monge_elkan_handicap_score THEN ''''monge_elkan_handicap''''          WHEN score_stats.highest_score = extended_scores.monge_elkan_quadratic_score THEN ''''monge_elkan_quadratic''''          WHEN score_stats.highest_score = extended_scores.monge_elkan_quadratic_handicap_score THEN ''''monge_elkan_quadratic_handicap''''          WHEN score_stats.highest_score = extended_scores.qgram_score THEN ''''qgram''''          WHEN score_stats.highest_score = extended_scores.trigram_score THEN ''''trigram''''          WHEN score_stats.highest_score = extended_scores.levenshtein_score THEN ''''levenshtein''''          WHEN score_stats.highest_score = extended_scores.jaro_score THEN ''''jaro''''          WHEN score_stats.highest_score = extended_scores.jaro_winkler_score THEN ''''jaro_winkler''''          WHEN score_stats.highest_score = score_stats.avg_score THEN ''''avg''''          WHEN score_stats.highest_score = score_stats.avg_quadratic_score THEN ''''avg_quadratic''''        ELSE ''''Undefined''''::citext END AS best_method,       score_stats.avg_score,       score_stats.avg_quadratic_score,       score_stats.lowest_score,       extended_scores.equality_check,       extended_scores.jaro_score,       extended_scores.jaro_winkler_score,       extended_scores.levenshtein_score,       extended_scores.monge_elkan_score,       extended_scores.monge_elkan_quadratic_score,       extended_scores.monge_elkan_handicap_score,       extended_scores.monge_elkan_quadratic_handicap_score,       extended_scores.qgram_score,       extended_scores.trigram_score  FROM extended_scores,       score_stats;'';BEGIN-------------------------------------------------------------- Safety checks for parameters stitched into the SQL.------------------------------------------------------------	IF base_text_in = '''' THEN		RAISE EXCEPTION USING			message = ''A base string must be supplied.'',			errcode = ''KC101''; -- Custom code for ''Empty string parameter''.    END IF;    monge_elkan_similarity_method_in  := lower(monge_elkan_similarity_method_in);	IF monge_elkan_similarity_method_in NOT IN (''jaro'',''jarowinkler'',''qgram'') THEN		RAISE EXCEPTION USING			message = ''Invalid distance measure name '''''' || monge_elkan_similarity_method_in || '''''''',			hint = ''Valid methods are jaro, jarowinkler, and qgram'',			errcode = ''KC300''; -- Custom code for ''Bad lookup ID''.    END IF;-------------------------------------------------------------- Range/sanity checks on thresholds------------------------------------------------------------	IF handicap_factor_in < 0 OR handicap_factor_in > 1 THEN		RAISE EXCEPTION USING			message = ''handicap_factor value is out of range.'',			hint = ''Value must be in the range 0-1.'',			errcode = ''KC202''; -- Custom code for ''Numeric parameter value is too low''.    END IF;-------------------------------------------------------------- If you''ve gotten this far, everything looks good. Run it!------------------------------------------------------------    RETURN QUERY EXECUTE sql    USING base_text_in,          comparison_text_in,          base_id_in,          comparison_id_in,          handicap_factor_in,          monge_elkan_similarity_method_in;END$function$', '', 'text', '{"comparator":"equals","column_order":"ignore","case_sensitivity":"blind","whitespace_cleaning":"all","normalize_line_endings":true}', 'Pass', '{user_change_structure}', FALSE, FALSE, '', '');