//%attributes = {"invisible":true,"folder":"PgSQL_pgIO","lang":"en"} comment added and reserved by 4D.If(False) pgIO_PushTrial_Edge   // DESCRIPTION: Push records from the [Edge] table to Nautilus. This time, through a function call.  // Place these declarations inCompiler_PgIO C_BOOLEAN(pgIO_PushTrial_Edge;$0)C_OBJECT(pgIO_PushTrial_Edge;$1)C_LONGINT(pgIO_PushTrial_Edge;$2)If (False) // Added: May 29, 2020. The field names and types of types_plus.edge_v1 are found below.// types_plus.edge_v1 is both an updatable view, and a type.//   id uuid,//   inv_id uuid,//   from_scan_at_facility_id uuid,//   from_associated_to_id uuid,//   to_associated_to_id uuid,//   from_web_user_id uuid,//   from_assembly_id uuid,//   from_scan_id uuid,//   from_sterilizer_load_id uuid,//   from_facility_location_id uuid,//   from_facility_id uuid,//   from_washer_load_id uuid,//   from_scase_id uuid,//   from_clinic_id uuid,//   from_facility_department_id uuid,//   hsys_id uuid,//   to_scan_id uuid,//   to_scan_at_facility_id uuid,//   to_web_user_id uuid,//   to_facility_location_id uuid,//   to_sterilizer_load_id uuid,//   to_washer_load_id uuid,//   to_facility_id uuid,//   to_scase_id uuid,//   to_clinic_id uuid,//   to_facility_department_id uuid,//   to_assembly_id uuid,//   num_inst integer,//   seconds integer,//   from_node_dts timestamp,//   to_node_dts timestamp,//   created_dts timestamp,//   updated_dts timestamp,//   sequence_ citext,//   from_node citext,//   to_node citext,//   from_to_node citext,//   from_associated_to citext,//   to_associated_to citext,//   from_user_name citext,//   source_ citext,//   is_fake citext,//   to_user_name citextEnd if  // CREATED BY: David Adams  // DATE: May 29, 2020  // LAST MODIFIED: End if   // ============================================Code_Start (Current method name)C_TEXT($table_name_in_postgres_text)$table_name_in_postgres_text:="edge"C_BOOLEAN($0;$ran_okay)C_OBJECT($1;$connection_o)C_LONGINT($2;$format_version_number)$connection_o:=$1  // Pass a good connection ID or you're toast.$format_version_number:=pgIOMap_GetMaxFormatVersion ($table_name_in_postgres_text)If (Count parameters>=2)$format_version_number:=$2End if $ran_okay:=FalseIf (pgIOMap_FormatVersionIsValid ($table_name_in_postgres_text;$format_version_number)=False)Code_Err ("";"Format version number "+String($format_version_number)+" is invalid.")End if If (Code_NotErr )C_LONGINT($connection_id)C_TEXT($insert_function_name)C_TEXT($pg_type_name)$connection_id:=$connection_o.connection_id$insert_function_name:="insert_"+$table_name_in_postgres_text+"_v"+String($format_version_number)  // Like insert_edge_v1$pg_type_name:=$table_name_in_postgres_text+"_v"+String($format_version_number)  // Like edge_v1. If ($connection_id<1)$ran_okay:=FalseElse $ran_okay:=True  //-------------------------------------------------------  // Find the unsent data  //-------------------------------------------------------C_LONGINT($table_number)C_LONGINT($first_conid_to_send_l)C_LONGINT($last_conid_to_send_l)C_LONGINT($records_count)$table_number:=pgIO_GetConIDsForTable (->[Edge];->$first_conid_to_send_l;->$last_conid_to_send_l)$records_count:=pgIO_LoadConIDRange (->[Edge];->[Edge]ConID;$first_conid_to_send_l;$last_conid_to_send_l)ORDER BY([Edge];[Edge]ConID)  // Important! Since we're chunking and bail if there's an error, it's important to keep track of the highest successful ConID sent.  //-------------------------------------------------------  // Prepare and push the data  //-------------------------------------------------------If ($records_count=0)$ran_okay:=TrueElse C_TEXT($cr)C_TEXT($tab)C_TEXT($sq)$cr:=Char(Carriage return)$tab:=Char(Tab)$sq:=Char(Quote)C_LONGINT($maximum_push_bytes)C_OBJECT($insert_o)$maximum_push_bytes:=Iam_GetPGMaximumPushKB *1024  // We want bytes to compare to the results from calling Length($values_text)$insert_o:=PgQuery_New ($connection_o;"";"pgIO_PushTrial_Edge")C_TEXT($data_file_id)$data_file_id:=PgConvert_UUID_ToPG_For_INSERT(<>sync_dataFileID_t)  // Fold the data into values statements.C_BLOB($code_blob)  // Accumulate in a BLOB, crazy faster than accumulating in a text var.SET BLOB SIZE($code_blob;0)C_LONGINT($push_data_size_bytes)C_BOOLEAN($push_now)C_TEXT($clause_text)C_LONGINT($record_index)For ($record_index;1;$records_count)If (BLOB size($code_blob)=0)  // Add the code to open up the function call and array parameter.TEXT TO BLOB("select * from "+$insert_function_name+"(array["+$cr;$code_blob;UTF8 text without length;*)End if   // GOTO SELECTED RECORD. Yeah, it rules. See:  // https://types_plus.atlassian.net/wiki/spaces/SON/pages/572817462/Loading+Data+Efficiently+for+Pushing+to+PostgresGOTO SELECTED RECORD([Edge];$record_index)$clause_text:=""$clause_text:=$clause_text+"("Case of // Each supported version has a case below. Older versions are left in place for testing in case we need to patch a lagging deployments.: ($format_version_number=1) // Added: May 29, 2020	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ID)+","// edge.id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]InvID)+","// edge.inv_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromScanAtFacilityID)+","// edge.from_scan_at_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromAssociatedToID)+","// edge.from_associated_to_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToAssociatedToID)+","// edge.to_associated_to_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromWebUserID)+","// edge.from_web_user_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromAssemblyID)+","// edge.from_assembly_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromScanID)+","// edge.from_scan_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromSterilizerLoadID)+","// edge.from_sterilizer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromFacilityLocationID)+","// edge.from_facility_location_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromFacilityID)+","// edge.from_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromWasherLoadID)+","// edge.from_washer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromSCaseID)+","// edge.from_scase_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromClinicID)+","// edge.from_clinic_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]FromFacilityDepartmentID)+","// edge.from_facility_department_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]HsysID)+","// edge.hsys_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToScanID)+","// edge.to_scan_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToScanAtFacilityID)+","// edge.to_scan_at_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToWebUserID)+","// edge.to_web_user_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToFacilityLocationID)+","// edge.to_facility_location_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToSterilizerLoadID)+","// edge.to_sterilizer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToWasherLoadID)+","// edge.to_washer_load_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToFacilityID)+","// edge.to_facility_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToSCaseID)+","// edge.to_scase_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToClinicID)+","// edge.to_clinic_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToFacilityDepartmentID)+","// edge.to_facility_department_id	$clause_text:=$clause_text+PgConvert_UUID_ToPG_For_INSERT([Edge]ToAssemblyID)+","// edge.to_assembly_id	$clause_text:=$clause_text+PgConvert_Number_ToPG([Edge]NumInst)+","// edge.num_inst	$clause_text:=$clause_text+PgConvert_Number_ToPG([Edge]Seconds)+","// edge.seconds	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]FromNodeDTS)+","// edge.from_node_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]ToNodeDTS)+","// edge.to_node_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]CreatedDTS)+","// edge.created_dts	$clause_text:=$clause_text+PgConvert_DTS_ToPG([Edge]UpdatedDTS)+","// edge.updated_dts	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]Sequence)+","// edge.sequence_	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromNode)+","// edge.from_node	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]ToNode)+","// edge.to_node	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromToNode)+","// edge.from_to_node	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromAssociatedTo)+","// edge.from_associated_to	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]ToAssociatedTo)+","// edge.to_associated_to	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]FromUserName)+","// edge.from_user_name	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]Source)+","// edge.source_	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]isFake)+","// edge.is_fake	$clause_text:=$clause_text+PgConvert_Text_ToPG([Edge]ToUserName)// edge.to_user_nameEnd case $clause_text:=$clause_text+")"$push_data_size_bytes:=BLOB size($code_blob)+Length($clause_text)Case of : ($record_index=$records_count)  // We've gone through all of the records.$push_now:=True: ($push_data_size_bytes>=$maximum_push_bytes)  // We've filled the buffer.$push_now:=TrueElse   // Keep on building the VALUES.$push_now:=FalseEnd case If ($push_now=False)$clause_text:=$clause_text+","+$cr  // We now *know* that we're going to add another value (statement), so we also know that we need a comma. The last (value) does *not* have a comma.Else $clause_text:=$clause_text+"]::"+$pg_type_name+"[]);" // Like edge_v1[]End if TEXT TO BLOB($clause_text;$code_blob;UTF8 text without length;*)$clause_text:=""If ($push_now)  // We've filled our buffer (based on max KB from IAM) or reached the last record. Push!   // This doubles memory consumption briefly. I asked Rob about a command that accepts a BLOB instead of text.  // He said "no" as it would require a text copy internally anyway, so it won't help. If memory is an issue,  // write to disk instead of text or BLOB and then use Document to text to load the block in one go.C_TEXT($push_text)  // The VALUES are built up in the loop below. When we've got all the records, or have filled our self-defined buffer, a push is sent.$push_text:=BLOB to text($code_blob;UTF8 text without length)SET BLOB SIZE($code_blob;0)  // Free up the RAM.If (False)SET TEXT TO PASTEBOARD($push_text)End if   // Jam the text right into the object...not calling PgQuery_SetSQLStatement here in case text is built (doubled) by for 4D for the parameter.OB SET($insert_o;PgQuery_Statement_SQL;$push_text)$push_text:=""  // Clear this now! It frees up memory before the push and makes sure that we don't keep resending old rows.$ran_okay:=PgQuery_Run ($insert_o)PgQuery_SetSQLStatement ($insert_o;"")  // Free up the memory taken by the SQL statement.If ($ran_okay)PgSQL_Execute ($connection_id;"COMMIT;")  //-------------------------------------------------------  // Update the last sent ConID  //-------------------------------------------------------  // This is why we sort by ConID up at the top. We're chunking through the number line and at each success, we plant a flag saying, "got this far!"If (SyncTables_SetLastConIDSentToPG ($table_number;[Edge]ConID)=False)  // Fails if record is locked or pushed value is lower than existing max value. Never decrement the max!  // Not bailing. We'll end up resending records in the future, but no harm should come of it.End if Else PgSQL_Execute ($connection_id;"ROLLBACK;")$record_index:=$records_count+1  // Break the loop. End if End if End for End if UNLOAD RECORD([Edge])End if $0:=$ran_okayIf ($ran_okay)  // Push an entry even if no records need to be sent.pgio_Push_PushLogEntry ($connection_o;$table_number;$table_name_in_postgres_text;$records_count)Else   // Just record the error. No alert. No global error set. Just a log entry.   // The program's state does not change, this is just a log entry.Code_ErrJustLogThis ("PgSQL_PushError";Current method name)End if End if Code_End (Current method name)