-- This is an extended version of fuzzy_match with extra details.DROP FUNCTION IF EXISTS tools.fuzzy_match_plus (citext, uuid, citext, citext, int4, float4, int4);CREATE OR REPLACE FUNCTION tools.fuzzy_match_plus (     base_text                           citext,     text_collection_id                  uuid,     winner_picked_by_column_name        citext DEFAULT 'best_score',     distance_measure_name               citext DEFAULT 'jarowinkler',     neighbors_to_check_max              int4   DEFAULT 25,     neighbor_similarity_threshold_min   float4 DEFAULT 0.2,     result_rows_max                     int4   DEFAULT 25)RETURNS TABLE (     neighbor_rank                int8,     text                         citext,     source_id                    citext,     neighbor_text                citext,     trigram_score                float4,     qgram_score                  float4,     distance_score               float4,     monge_elkan_score            float4,     monge_elkan_quadratic_score  float4,     best_score                   float4,     average_score                float4,     best_score_method            citext)AS $BODY$DECLARE-------------------------------------------------------------- Setup query template, which you can RAISE NOTICE while .-- developing to see what's in it.------------------------------------------------------------sql text := 'WITHnear_neighbors AS (  select distinct on (text <-> $1) text,                     (text <-> $1)                    AS trigram_score,                      qgram($1, text)                 AS qgram_score,                      monge_elkan($1, text)           AS monge_elkan_score,                      sqrt(monge_elkan($1, text))     AS monge_elkan_quadratic_score,                      ' || distance_measure_name || ' ($1, text) AS distance_score,                      text AS neighbor_text,                      source_id,                      DENSE_RANK() OVER(ORDER BY text <-> $1) AS neighbor_rank         from text_collection_item    where collection_id = $2        limit $5),near_neighbors_normalized AS (select neighbor_rank,       text,       source_id,       neighbor_text,       (trigram_score -1) * -1 AS trigram_score, -- Flip scale so that a higher score = more similar       qgram_score,       distance_score,       monge_elkan_score,       monge_elkan_quadratic_score,      -- Ugh. Bound to be a nicer way with arrays or something. Maybe another day.        (CASE             WHEN trigram_score > qgram_score AND                  trigram_score > distance_score AND                  trigram_score > monge_elkan_score AND                  trigram_score > monge_elkan_quadratic_score THEN                  trigram_score             WHEN qgram_score > trigram_score AND                  qgram_score > distance_score AND                  qgram_score > monge_elkan_score AND                  qgram_score > monge_elkan_quadratic_score THEN                  qgram_score             WHEN distance_score > trigram_score     AND                  distance_score > qgram_score       AND                  distance_score > monge_elkan_score AND                  distance_score > monge_elkan_quadratic_score THEN                  distance_score             WHEN monge_elkan_score > trigram_score   AND                  monge_elkan_score > qgram_score     AND                  monge_elkan_score > distance_score  AND                  monge_elkan_score > monge_elkan_quadratic_score  THEN                  monge_elkan_score             ELSE monge_elkan_quadratic_score            END) as best_score,        (CASE             WHEN trigram_score > qgram_score AND                  trigram_score > distance_score AND                  trigram_score > monge_elkan_score AND                  trigram_score > monge_elkan_quadratic_score THEN                  ''trigram''             WHEN qgram_score > trigram_score AND                  qgram_score > distance_score AND                  qgram_score > monge_elkan_score AND                  qgram_score > monge_elkan_quadratic_score THEN                  ''qgram''             WHEN distance_score > trigram_score     AND                  distance_score > qgram_score       AND                  distance_score > monge_elkan_score AND                  distance_score > monge_elkan_quadratic_score THEN                  ''distance''             WHEN monge_elkan_score > trigram_score   AND                  monge_elkan_score > qgram_score     AND                  monge_elkan_score > distance_score  AND                  monge_elkan_score > monge_elkan_quadratic_score  THEN                  ''monge_elkan''             ELSE ''monge_elkan_quadratic''            END) as best_score_method,          greatest(trigram_score, qgram_score) +          distance_score +          monge_elkan_score +          monge_elkan_quadratic_score AS combined_score   from near_neighbors),-- Woah! Hard to track down bug here, need to have the floats cast before sorting.-- Welsh spotted some weird ordering, seems to be this. Hmm. Not really fixed.castings AS ( select neighbor_rank,        text,        source_id,        neighbor_text,       ((trigram_score -1) * -1)::float 4 AS trigram_score, -- Flip scale so that a higher score = more similar        qgram_score::float4,        distance_score::float4,        monge_elkan_score::float4,        monge_elkan_quadratic_score::float4,        best_score::float4,        CASE WHEN combined_score = 0::float4 THEN 0 ELSE (combined_score/4)::float4 END AS average_score,        best_score_method::citext   from near_neighbors_normalized   where trigram_score >= $6)select * from castingsorder by $3 DESClimit $7;';BEGIN-- RAISE NOTICE '%', sql;-------------------------------------------------------------- Existence check for the text_collection------------------------------------------------------------     IF NOT EXISTS (select 1 from text_collection where id = text_collection_id) THEN          RAISE EXCEPTION USING               message = 'text_collection not found with id = ''' || text_collection_id || '''',               errcode = 'KC100'; -- Custom code for 'Bad string selector parameter value'.    END IF;-------------------------------------------------------------- Safety checks for parameters stitched into the SQL.------------------------------------------------------------    distance_measure_name  := lower(distance_measure_name);     IF distance_measure_name NOT IN ('jaro','jarowinkler','qgram') THEN          RAISE EXCEPTION USING               message = 'Invalid distance measure name ''' || distance_measure_name || '''',               hint = 'Valid methods are jaro, jarowinkler, and qgram',               errcode = 'KC100'; -- Custom code for 'Bad string selector parameter value'.    END IF;    winner_picked_by_column_name  := lower(winner_picked_by_column_name);     IF winner_picked_by_column_name NOT IN ('average_score', 'best_score', 'distance_score', 'monge_elkan_score',     'monge_elkan_quadratic_score','qgram_score', 'trigram_score') THEN          RAISE EXCEPTION USING               message = 'Invalid winning column name ''' || winner_picked_by_column_name || '''',               hint = 'Valid names are  average_score, best_score, distance_score, monge_elkan_score, monge_elkan_quadratic_score, qgram_score, and trigram_score.',               errcode = 'KC100'; -- Custom code for 'Bad string selector parameter value'.    END IF;-------------------------------------------------------------- Range/sanity checks on thresholds------------------------------------------------------------     IF neighbors_to_check_max < 1 THEN          RAISE EXCEPTION USING               message = 'neighbors_to_check_max value is too low.',               hint = 'Value must be 1 or higher.',               errcode = 'KC200'; -- Custom code for 'Numeric parameter value is too low'.    END IF;     IF result_rows_max < 1 THEN          RAISE EXCEPTION USING               message = 'result_rows_max value is too low.',               hint = 'Value must be 1 or higher.',               errcode = 'KC200'; -- Custom code for 'Numeric parameter value is too low'.    END IF;     IF neighbor_similarity_threshold_min < 0 OR neighbor_similarity_threshold_min > 1 THEN          RAISE EXCEPTION USING               message = 'neighbor_similarity_threshold_min value is out of range.',               hint = 'Value must be in the range 0-1.',               errcode = 'KC202'; -- Custom code for 'Numeric parameter value is too low'.    END IF;-------------------------------------------------------------- If you've gotten this far, everything looks good. Run it!------------------------------------------------------------    RETURN QUERY EXECUTE sql    USING base_text,          text_collection_id,          winner_picked_by_column_name,          distance_measure_name,          neighbors_to_check_max,          neighbor_similarity_threshold_min,          result_rows_max;END$BODY$LANGUAGE plpgsql;ALTER FUNCTION tools.fuzzy_match_plus (citext, uuid, citext, citext, int4, float4, int4)     OWNER TO user_bender;