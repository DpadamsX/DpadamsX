DROP FUNCTION IF EXISTS tools.fuzzy_match (citext, uuid, citext, int4, float4, int4);CREATE OR REPLACE FUNCTION tools.fuzzy_match (     base_text                           citext,     text_collection_id                  uuid,     distance_measure_name               citext DEFAULT 'jarowinkler',     neighbors_to_check_max              int4   DEFAULT 25,     neighbor_similarity_threshold_min   float4 DEFAULT 0.2,     result_rows_max                     int4   DEFAULT 25)RETURNS TABLE (     neighbor_rank                int8,     text                         citext,     neighbor_text                citext,     source_id                    citext,     best_score                   float4,     average_score                float4,     monge_elkan_score            float4,     monge_elkan_quadratic_score  float4,	 equality_check               int4,     distance_score               float4,     qgram_score                  float4,     trigram_score                float4)AS $BODY$DECLARE-------------------------------------------------------------- Setup query template, which you can RAISE NOTICE while .-- developing to see what's in it.------------------------------------------------------------sql text := 'WITHnear_neighbors AS (  select distinct on (text <-> $1)             text,                      text AS neighbor_text,                      source_id,                      monge_elkan($1, text)       AS monge_elkan_score,                      sqrt(monge_elkan($1, text)) AS monge_elkan_quadratic_score,                      ' || distance_measure_name || ' ($1, text) AS distance_score,                      qgram($1, text)             AS qgram_score,                     (text <-> $1)                AS trigram_score,                      DENSE_RANK() OVER(ORDER BY text <-> $1) as neighbor_rank         from text_collection_item    where collection_id = $2        limit $5),near_neighbors_normalized AS (select neighbor_rank,       text,       source_id,       neighbor_text,       (text = neighbor_text)::int4              AS equality_check,       (trigram_score -1) * -1 AS trigram_score, -- Flip scale so that a higher score = more similar       qgram_score,       distance_score,       monge_elkan_score,       greatest(greatest(trigram_score,qgram_score), distance_score, monge_elkan_score, (text = neighbor_text)::int4) AS best_score,       greatest(trigram_score,qgram_score) + distance_score + monge_elkan_score + (text = neighbor_text)::int4  AS combined_score   from near_neighbors) select neighbor_rank,        text,        source_id,        neighbor_text,       ((trigram_score -1) * -1)::float4 AS trigram_score, -- Flip scale so that a higher score = more similar        qgram_score::float4,        distance_score::float4,        monge_elkan_score::float4,        monge_elkan_quadratic_score::float4,        best_score::float4,        CASE WHEN combined_score = 0::float4 THEN 0 ELSE (combined_score/5)::float4 END AS average_score   from near_neighbors_normalized   where trigram_score >= $5-- Order by to try and improve outputs when multiple measures have the same best_score.order by best_score,         equality_check,         monge_elkan_quadratic_score,         monge_elkan_score,         qgram_scorelimit $6;';BEGIN-------------------------------------------------------------- Existence check for the text_collection------------------------------------------------------------	IF NOT EXISTS (select 1 from text_collection where id = text_collection_id) THEN		RAISE EXCEPTION USING			message = 'text_collection not found with id = ''' || text_collection_id || '''',			errcode = 'KC100'; -- Custom code for 'Bad string selector parameter value'.    END IF;-------------------------------------------------------------- Safety checks for parameters stitched into the SQL.------------------------------------------------------------    distance_measure_name  := lower(distance_measure_name);	IF distance_measure_name NOT IN ('jaro','jarowinkler','qgram') THEN		RAISE EXCEPTION USING			message = 'Invalid distance measure name ''' || distance_measure_name || '''',			hint = 'Valid methods are jaro, jarowinkler, and qgram',			errcode = 'KC300'; -- Custom code for 'Bad lookup ID'.    END IF;-------------------------------------------------------------- Range/sanity checks on thresholds------------------------------------------------------------	IF neighbors_to_check_max < 1 THEN		RAISE EXCEPTION USING			message = 'neighbors_to_check_max value is too low.',			hint = 'Value must be 1 or higher.',			errcode = 'KC200'; -- Custom code for 'Numeric parameter value is too low'.    END IF;	IF result_rows_max < 1 THEN		RAISE EXCEPTION USING			message = 'result_rows_max value is too low.',			hint = 'Value must be 1 or higher.',			errcode = 'KC200'; -- Custom code for 'Numeric parameter value is too low'.    END IF;	IF neighbor_similarity_threshold_min < 0 OR neighbor_similarity_threshold_min > 1 THEN		RAISE EXCEPTION USING			message = 'neighbor_similarity_threshold_min value is out of range.',			hint = 'Value must be in the range 0-1.',			errcode = 'KC202'; -- Custom code for 'Numeric parameter value is too low'.    END IF;-------------------------------------------------------------- If you've gotten this far, everything looks good. Run it!------------------------------------------------------------    RETURN QUERY EXECUTE sql    USING base_text,          text_collection_id,          distance_measure_name,          neighbors_to_check_max,          neighbor_similarity_threshold_min,          result_rows_max;END$BODY$LANGUAGE plpgsql;ALTER FUNCTION tools.fuzzy_match (citext, uuid, citext, int4, float4, int4)     OWNER TO user_bender;