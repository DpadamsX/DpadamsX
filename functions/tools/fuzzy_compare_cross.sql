DROP FUNCTION IF EXISTS tools.fuzzy_compare_cross (jsonb, jsonb, real, citext);CREATE OR REPLACE FUNCTION tools.fuzzy_compare_cross (     base_jsonb_in                        jsonb,     comparison_jsonb_in                  jsonb,     handicap_factor_in                   real DEFAULT 0.3,     monge_elkan_similarity_method_in     citext DEFAULT 'jarowinkler')-- decimal_score is a custom domain (type) for ###.##### numbers.RETURNS TABLE (     base_text                             citext,     comparison_text                       citext,     base_id                               citext,     comparison_id                         citext,     highest_score                         decimal_score,     best_method                           citext,     avg_score                             decimal_score,     avg_quadratic_score                   decimal_score,     lowest_score                          decimal_score,     equality_check                        int4,     jaro_score                            decimal_score,     jaro_winkler_score                    decimal_score,     levenshtein_score                     decimal_score,     monge_elkan_score                     decimal_score,     monge_elkan_quadratic_score           decimal_score,     monge_elkan_handicap_score            decimal_score,     monge_elkan_quadratic_handicap_score  decimal_score,     qgram_score                           decimal_score,     trigram_score                         decimal_score)AS $BODY$BEGIN-------------------------------------------------------------- Safety checks for parameters stitched into the SQL.------------------------------------------------------------    monge_elkan_similarity_method_in  := lower(monge_elkan_similarity_method_in);	IF monge_elkan_similarity_method_in NOT IN ('jaro','jarowinkler','qgram') THEN		RAISE EXCEPTION USING			message = 'Invalid distance measure name ' || monge_elkan_similarity_method_in,			hint = 'Valid methods are jaro, jarowinkler, and qgram',			errcode = 'KC300'; -- Custom code for 'Bad lookup ID'.    END IF;-------------------------------------------------------------- Range/sanity checks on thresholds------------------------------------------------------------	IF handicap_factor_in < 0 OR handicap_factor_in > 1 THEN		RAISE EXCEPTION USING			message = 'handicap_factor value is out of range.',			hint = 'Value must be in the range 0-1.',			errcode = 'KC202'; -- Custom code for 'Numeric parameter value is too low'.    END IF;RETURN QUERYWITHbase_expanded AS ( select *   from jsonb_to_recordset(     base_jsonb_in)  AS base_unpacked (                 text citext,                 id citext) ),comparison_expanded AS ( select *   from jsonb_to_recordset(     comparison_jsonb_in)  AS comparison_unpacked (                 text citext,                 id citext) ),combined_lists AS (select base_expanded.text         AS base_text_x,       base_expanded.id           AS base_id_x,       comparison_expanded.text   AS comparison_text_x,       comparison_expanded.id     AS comparison_id_x  from base_expanded,       comparison_expanded),---------------------------------------------------------- Pull in the basic scores, and add some handicaps--------------------------------------------------------basic_scores AS (select base_text_x,       comparison_text_x,       base_id_x,       comparison_id_x,       (base_text_x = comparison_text_x)::int4                                              AS equality_check_x,       monge_elkan(base_text_x, comparison_text_x, monge_elkan_similarity_method_in)        AS monge_elkan_score_x,       sqrt(monge_elkan(base_text_x, comparison_text_x, monge_elkan_similarity_method_in))  AS monge_elkan_quadratic_score_x,       jaccard(base_text_x, comparison_text_x)                                              AS jaccard_coefficient_x,       jaccard(base_text_x, comparison_text_x) * handicap_factor_in                         AS jaccard_handicap_x,       qgram(base_text_x,comparison_text_x)                                                 AS qgram_score_x,       similarity(base_text_x,comparison_text_x)                                            AS trigram_score_x,       lev(base_text_x,comparison_text_x)                                                   AS levenshtein_score_x,       jaro(base_text_x,comparison_text_x)                                                  AS jaro_score_x,       jarowinkler(base_text_x,comparison_text_x)                                           AS jaro_winkler_score_x  from combined_lists),---------------------------------------------------------- Pull in the basic scores, and add some handicaps--------------------------------------------------------extended_scores AS (SELECT  base_text_x,        comparison_text_x,        base_id_x,        comparison_id_x,        equality_check_x,        jaro_score_x,        jaro_winkler_score_x,        levenshtein_score_x,        monge_elkan_score_x,        monge_elkan_quadratic_score_x,        (monge_elkan_score_x - jaccard_handicap_x) AS monge_elkan_handicap_score_x,        (monge_elkan_quadratic_score_x - jaccard_handicap_x) AS monge_elkan_quadratic_handicap_score_x,        jaccard_coefficient_x,        jaccard_handicap_x,        qgram_score_x,        trigram_score_x  FROM basic_scores),---------------------------------------------------------- Augment with overall stats on range of scores--------------------------------------------------------  score_stats AS (  SELECT base_text_x,         comparison_text_x,         base_id_x,         comparison_id_x,         equality_check_x,         jaro_score_x,         jaro_winkler_score_x,         levenshtein_score_x,         monge_elkan_score_x,         monge_elkan_quadratic_score_x,         monge_elkan_handicap_score_x,         monge_elkan_quadratic_handicap_score_x,         jaccard_coefficient_x,         jaccard_handicap_x,         qgram_score_x,         trigram_score_x,           GREATEST (           equality_check_x,           jaro_score_x,           jaro_winkler_score_x,           levenshtein_score_x,           monge_elkan_score_x,           monge_elkan_handicap_score_x,           monge_elkan_quadratic_score_x,           monge_elkan_quadratic_handicap_score_x,           qgram_score_x,           trigram_score_x) AS highest_score_x,-- Leave out equality_check_x out of LEAST and AVG scores. It's either 0 or 1, almost always 0.        LEAST (           jaro_score_x,           jaro_winkler_score_x,           levenshtein_score_x,           monge_elkan_score_x,           monge_elkan_handicap_score_x,           monge_elkan_quadratic_score_x,           monge_elkan_quadratic_handicap_score_x,           qgram_score_x,           trigram_score_x) AS lowest_score_x,         ((jaro_score_x +           jaro_winkler_score_x +           levenshtein_score_x +           monge_elkan_score_x +           monge_elkan_handicap_score_x +           monge_elkan_quadratic_score_x +           monge_elkan_quadratic_handicap_score_x +           qgram_score_x +           trigram_score_x) / 10) AS avg_score_x,           sqrt((jaro_score_x +           jaro_winkler_score_x +           levenshtein_score_x +           monge_elkan_score_x +           monge_elkan_handicap_score_x +           monge_elkan_quadratic_score_x +           monge_elkan_quadratic_handicap_score_x +           qgram_score_x +           trigram_score_x) / 10) AS avg_quadratic_score_x     FROM extended_scores        )---------------------------------------------------------- Final result: Get everything, along with the top score--------------------------------------------------------SELECT base_text_x,       comparison_text_x,       base_id_x,       comparison_id_x,       highest_score_x::decimal_score,        -- Ugh. Researching better methods for doing this part...and some of the others...bit too long.        -- In case of a tie, this code picks the first match.       CASE          WHEN highest_score_x = 0                                      THEN 'none'          WHEN highest_score_x = equality_check_x                       THEN 'equality_check'          WHEN highest_score_x = monge_elkan_score_x                    THEN 'monge_elkan'          WHEN highest_score_x = monge_elkan_handicap_score_x           THEN 'monge_elkan_handicap'          WHEN highest_score_x = monge_elkan_quadratic_score_x          THEN 'monge_elkan_quadratic'          WHEN highest_score_x = monge_elkan_quadratic_handicap_score_x THEN 'monge_elkan_quadratic_handicap'          WHEN highest_score_x = qgram_score_x                          THEN 'qgram'          WHEN highest_score_x = trigram_score_x                        THEN 'trigram'          WHEN highest_score_x = levenshtein_score_x                    THEN 'levenshtein'          WHEN highest_score_x = jaro_score_x                           THEN 'jaro'          WHEN highest_score_x = jaro_winkler_score_x                   THEN 'jaro_winkler'          WHEN highest_score_x = avg_score_x                            THEN 'avg'          WHEN highest_score_x = avg_quadratic_score_x                  THEN 'avg_quadratic'          ELSE 'Undefined'::citext        END AS best_method,       avg_score_x::decimal_score,       avg_quadratic_score_x::decimal_score,       lowest_score_x::decimal_score,       equality_check_x::int4,       jaro_score_x::decimal_score::decimal_score,       jaro_winkler_score_x::decimal_score,       levenshtein_score_x::decimal_score,       monge_elkan_score_x::decimal_score,       monge_elkan_quadratic_score_x::decimal_score,       monge_elkan_handicap_score_x::decimal_score,       monge_elkan_quadratic_handicap_score_x::decimal_score,       qgram_score_x::decimal_score,       trigram_score_x::decimal_score  FROM score_stats;END$BODY$LANGUAGE plpgsql;ALTER FUNCTION tools.fuzzy_compare_cross (jsonb, jsonb, real, citext)     OWNER TO user_bender;