CREATE OR REPLACE FUNCTION "tools"."fuzzy_compare_pairwise"("base_jsonb_in" jsonb, "comparison_jsonb_in" jsonb, "handicap_factor_in" float4=0.3, "monge_elkan_similarity_method_in" "extensions"."citext"='jarowinkler'::citext)  RETURNS TABLE("base_text" "extensions"."citext", "comparison_text" "extensions"."citext", "base_id" "extensions"."citext", "comparison_id" "extensions"."citext", "highest_score" "domains"."decimal_score", "best_method" "extensions"."citext", "avg_score" "domains"."decimal_score", "avg_quadratic_score" "domains"."decimal_score", "lowest_score" "domains"."decimal_score", "equality_check" int4, "jaro_score" "domains"."decimal_score", "jaro_winkler_score" "domains"."decimal_score", "levenshtein_score" "domains"."decimal_score", "monge_elkan_score" "domains"."decimal_score", "monge_elkan_quadratic_score" "domains"."decimal_score", "monge_elkan_handicap_score" "domains"."decimal_score", "monge_elkan_quadratic_handicap_score" "domains"."decimal_score", "qgram_score" "domains"."decimal_score", "trigram_score" "domains"."decimal_score") AS $BODY$BEGIN-------------------------------------------------------------- Safety checks for parameters stitched into the SQL.------------------------------------------------------------    monge_elkan_similarity_method_in  := lower(monge_elkan_similarity_method_in);    IF monge_elkan_similarity_method_in NOT IN ('jaro','jarowinkler','qgram') THEN        RAISE EXCEPTION USING            message = 'Invalid distance measure name ' || monge_elkan_similarity_method_in,            hint = 'Valid methods are jaro, jarowinkler, and qgram',            errcode = 'KC300'; -- Custom code for 'Bad lookup ID'.    END IF;-------------------------------------------------------------- Range/sanity checks on thresholds------------------------------------------------------------    IF handicap_factor_in < 0 OR handicap_factor_in > 1 THEN        RAISE EXCEPTION USING            message = 'handicap_factor value is out of range.',            hint = 'Value must be in the range 0-1.',            errcode = 'KC202'; -- Custom code for 'Numeric parameter value is too low'.    END IF;RETURN QUERYWITHbase_expanded AS (   SELECT * FROM jsonb_array_elements(base_jsonb_in::jsonb)      WITH ORDINALITY AS x(element, idx)),comparison_expanded AS (   SELECT * FROM jsonb_array_elements(comparison_jsonb_in::jsonb) WITH ORDINALITY AS y(element, idx) ),-- Pairwise JOIN using ordinality-geneated index as the joining term.-- So, base element 1 to comaprison element 1, and so on.combined_lists AS (select base_expanded.element ->> 'text'        AS base_text_x,       base_expanded.element ->> 'id'          AS base_id_x,       comparison_expanded.element ->> 'text'  AS comparison_text_x,       comparison_expanded.element ->> 'id'    AS comparison_id_x  from base_expanded  join comparison_expanded ON (comparison_expanded.idx = base_expanded.idx)),---------------------------------------------------------- Pull in the basic scores, and add some handicaps--------------------------------------------------------basic_scores AS (select base_text_x,       comparison_text_x,       base_id_x,       comparison_id_x,       (base_text_x = comparison_text_x)::int4                                              AS equality_check_x,       monge_elkan(base_text_x, comparison_text_x,monge_elkan_similarity_method_in)         AS monge_elkan_score_x,       sqrt(monge_elkan(base_text_x, comparison_text_x, monge_elkan_similarity_method_in))  AS monge_elkan_quadratic_score_x,       jaccard(base_text_x,comparison_text_x)                                               AS jaccard_coefficient,       jaccard(base_text_x,comparison_text_x) * handicap_factor_in                          AS jaccard_handicap,       qgram(base_text_x,comparison_text_x)                                                 AS qgram_score_x,       similarity(base_text_x,comparison_text_x)                                            AS trigram_score_x,       lev(base_text_x,comparison_text_x)                                                   AS levenshtein_score_x,       jaro(base_text_x,comparison_text_x)                                                  AS jaro_score_x,       jarowinkler(base_text_x,comparison_text_x)                                           AS jaro_winkler_score_x  from combined_lists),---------------------------------------------------------- Pull in the basic scores, and add some handicaps--------------------------------------------------------extended_scores AS (SELECT  base_text_x,        comparison_text_x,        base_id_x,        comparison_id_x,        equality_check_x,        jaro_score_x::decimal_score,        jaro_winkler_score_x::decimal_score,        levenshtein_score_x::decimal_score,        monge_elkan_score_x::decimal_score,        monge_elkan_quadratic_score_x::decimal_score,        (monge_elkan_score_x - jaccard_handicap)::decimal_score AS monge_elkan_handicap_score_x,        (monge_elkan_quadratic_score_x - jaccard_handicap)::decimal_score AS monge_elkan_quadratic_handicap_score_x,        jaccard_coefficient,        jaccard_handicap,        qgram_score_x::decimal_score,        trigram_score_x::decimal_score  FROM basic_scores),---------------------------------------------------------- Augment with overall stats on range of scores--------------------------------------------------------  score_stats AS (  SELECT base_text_x,         comparison_text_x,         base_id_x,         comparison_id_x,         equality_check_x,         jaro_score_x,         jaro_winkler_score_x,         levenshtein_score_x,         monge_elkan_score_x,         monge_elkan_quadratic_score_x,         monge_elkan_handicap_score_x,         monge_elkan_quadratic_handicap_score_x,         jaccard_coefficient,         jaccard_handicap,         qgram_score_x,         trigram_score_x,           GREATEST (           equality_check_x,           jaro_score_x,           jaro_winkler_score_x,           levenshtein_score_x,           monge_elkan_score_x,           monge_elkan_handicap_score_x,           monge_elkan_quadratic_score_x,           monge_elkan_quadratic_handicap_score_x,           qgram_score_x,           trigram_score_x)::decimal_score AS highest_score_x,-- Leave out equality_check_x out of LEAST and AVG scores. It's either 0 or 1, almost always 0.        LEAST (           jaro_score_x,           jaro_winkler_score_x,           levenshtein_score_x,           monge_elkan_score_x,           monge_elkan_handicap_score_x,           monge_elkan_quadratic_score_x,           monge_elkan_quadratic_handicap_score_x,           qgram_score_x,           trigram_score_x)::decimal_score AS lowest_score_x,         ((jaro_score_x +           jaro_winkler_score_x +           levenshtein_score_x +           monge_elkan_score_x +           monge_elkan_handicap_score_x +           monge_elkan_quadratic_score_x +           monge_elkan_quadratic_handicap_score_x +           qgram_score_x +           trigram_score_x) / 10)::decimal_score AS avg_score_x,           sqrt((jaro_score_x +           jaro_winkler_score_x +           levenshtein_score_x +           monge_elkan_score_x +           monge_elkan_handicap_score_x +           monge_elkan_quadratic_score_x +           monge_elkan_quadratic_handicap_score_x +           qgram_score_x +           trigram_score_x) / 10)::decimal_score AS avg_quadratic_score_x     FROM extended_scores        )---------------------------------------------------------- Final result: Get everything, along with the top score--------------------------------------------------------SELECT base_text_x::citext,       comparison_text_x::citext,       base_id_x::citext,       comparison_id_x::citext,       highest_score_x,        -- Ugh. Researching better methods for doing this part...and some of the others...bit too long.        -- In case of a tie, this code picks the first match.       CASE          WHEN highest_score_x = 0 THEN 'none'          WHEN highest_score_x = monge_elkan_score_x                    THEN 'monge_elkan'          WHEN highest_score_x = monge_elkan_handicap_score_x           THEN 'monge_elkan_handicap'          WHEN highest_score_x = monge_elkan_quadratic_score_x          THEN 'monge_elkan_quadratic'          WHEN highest_score_x = monge_elkan_quadratic_handicap_score_x THEN 'monge_elkan_quadratic_handicap'          WHEN highest_score_x = qgram_score_x                          THEN 'qgram'          WHEN highest_score_x = trigram_score_x                        THEN 'trigram'          WHEN highest_score_x = levenshtein_score_x                    THEN 'levenshtein'          WHEN highest_score_x = jaro_score_x                           THEN 'jaro'          WHEN highest_score_x = jaro_winkler_score_x                   THEN 'jaro_winkler'          WHEN highest_score_x = avg_score_x                            THEN 'avg'          WHEN highest_score_x = avg_quadratic_score_x                  THEN 'avg_quadratic'          ELSE 'Undefined'::citext        END AS best_method_x,       avg_score_x,       avg_quadratic_score_x,       lowest_score_x,       equality_check_x,       jaro_score_x,       jaro_winkler_score_x,       levenshtein_score_x,       monge_elkan_score_x,       monge_elkan_quadratic_score_x,       monge_elkan_handicap_score_x,       monge_elkan_quadratic_handicap_score_x,       qgram_score_x,       trigram_score_x  FROM score_stats;END$BODY$  LANGUAGE plpgsql VOLATILE  COST 100  ROWS 1000