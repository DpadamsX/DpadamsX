------------------------------------------------------ CREATE FUNCTION on_ddl_create_or_alter----------------------------------------------------DROP FUNCTION IF EXISTS event_triggers.on_ddl_create_or_alter() CASCADE;CREATE FUNCTION event_triggers.on_ddl_create_or_alter()        RETURNS event_trigger AS$BODY$BEGININSERT INTO dba.ddl_event_log (			classid,			objid,			objsubid,			command_tag,			in_extension,			object_identity,			object_type,			schema_name,			trigger_event) --,			-- object_source)	SELECT	ec.classid,			ec.objid,			ec.objsubid,			ec.command_tag,			ec.in_extension,			ec.object_identity,			ec.object_type,			ec.schema_name,			TG_EVENT			-- ddl_get_object_source(ec.object_type,ec.objid)       FROM pg_event_trigger_ddl_commands() AS ec  LEFT JOIN pg_proc on pg_proc.oid = ec.objid      WHERE TG_TAG IS NOT NULL AND            command_tag NOT IN ('GRANT','REVOKE','ALTER DEFAULT PRIVILEGES');      -- Unclear why some are null, seems to be on low-level rewrites?  ¯\_(ツ)_/¯END$BODY$	LANGUAGE plpgsql;-- The code above defines the function, but does *not* build the event_trigger binding.-- That code is handled in a distinct operation.-- The object_source field population code call to ddl_get_object_source isn't working right,-- don't really need it, setting it aside for now.