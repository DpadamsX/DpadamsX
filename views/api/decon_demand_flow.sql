DROP VIEW IF EXISTS api.decon_demand_flow CASCADE;CREATE VIEW api.decon_demand_flow AS----------------------------------------------------------- Build matrix of hours + facilities + associated_to---------------------------------------------------------WITH-- Keep the date range here compatible with the WHERE clause in the analytic data query.date_range AS (select (current_date - interval '8 weeks') as first_dts,        current_date + interval '1 day' - interval '1 sec' as last_dts -- 1 second before midnight   ),-- https://stackoverflow.com/questions/29023336/generate-series-in-postgres-from-start-and-end-date-in-a-table.-- LATERAL JOIN with generate_series.hours AS (select date_hour  from date_range,       generate_series(date_range.first_dts, date_range.last_dts, interval '1 hour') g(date_hour)),associated_to AS (         select associated_to AS "AssociatedTo",                count(*) as row_count            from analytic_scan       where associated_to <> ''    group by associated_to    having count(*) >= 10 -- Screen out some rare, weird values.),hours_associated_to AS (-- CROSS JOIN (full Cartesian product)select --hours.date_hour,       hours.date_hour::date                              AS "ScanTime_Date",      (date_part('dow'::text, hours.date_hour))::integer  AS "ScanTime_DayOfWeek",       to_char(hours.date_hour, 'Day'::text)              AS "ScanTime_DayName",      (date_part('hour'::text, hours.date_hour))::integer AS "ScanTime_HourOfDay",       associated_to."AssociatedTo" from hours,      associated_to ), facilities AS ( select distinct ON ("FacilityName")        "FacilityName",        "HsysName"   from analytic_scan_domo  group by 1,2), join_matrix AS ( -- Another big CROSS JOIN. The end result is facilities * hours * associated_to rows. This is a full range, with empty slots. -- The analytic data is then joined in to fill in whatever slots apply.  select facilities."FacilityName",         facilities."HsysName",         hours_associated_to."ScanTime_Date",         hours_associated_to."ScanTime_DayOfWeek",         hours_associated_to."ScanTime_DayName",         hours_associated_to."ScanTime_HourOfDay",         hours_associated_to."AssociatedTo"    from facilities,         hours_associated_to),----------------------------------------------------------- Build analytic results----------------------------------------------------------- Get only the data needed from analytic_scan.-- Notice that the date WHERE is in here, that helps with the speed.analytic_scan_data AS (    select GREATEST(1, analytic_scan.num_inst)                                   AS "NumInst",           analytic_scan.tray_or_pack                                            AS "TrayOrPack",           COALESCE(hsys.name_, ''::citext)                                      AS "HsysName",           COALESCE(facility.name_, ''::citext)                                  AS "FacilityName",           analytic_scan.associated_to                                           AS "AssociatedTo",           date(analytic_scan.scan_time_local_dts)                               AS "ScanTime_Date",           (date_part('dow'::text, analytic_scan.scan_time_local_dts))::integer  AS "ScanTime_DayOfWeek",           to_char(analytic_scan.scan_time_local_dts, 'Day'::text)               AS "ScanTime_DayName",           (date_part('hour'::text, analytic_scan.scan_time_local_dts))::integer AS "ScanTime_HourOfDay"    from  analytic_scan     join facility ON (analytic_scan.facility_id = facility.id)     join hsys     ON (facility.hsys_id          = hsys.id)   where analytic_scan.scan_time_local_dts >= (current_date - interval '8 weeks')-- Keep the WHERE condition here in line with date_range up at the top.),-- Get the basic details and counts. These values then have names that can be used-- in the following CTE ("WITH" search)total as (SELECT  "HsysName",  "FacilityName",  "ScanTime_Date",  "ScanTime_DayOfWeek",  "ScanTime_DayName",  "ScanTime_HourOfDay",  "AssociatedTo",  SUM("NumInst") as totalflow,  COUNT("TrayOrPack") as trayflowFROM  analytic_scan_dataGROUP BY  "HsysName",  "FacilityName",  "ScanTime_Date",  "ScanTime_DayOfWeek",  "ScanTime_DayName",  "ScanTime_HourOfDay",  "AssociatedTo"),analytic_scan_data_final AS (-- Final results, pull everything together.SELECT  "HsysName",  "FacilityName",  "ScanTime_Date",  "ScanTime_DayOfWeek",  "ScanTime_DayName",  "ScanTime_HourOfDay",  "AssociatedTo",  AVG (totalflow) AS "AvgInstFlow",  AVG (trayflow)  As "AvgTrayFlow"FROM totalWHERE "FacilityName"  IS NOT NULL  AND "ScanTime_Date" IS NOT NULLGROUP BY  "HsysName",  "FacilityName",  "ScanTime_Date",  "ScanTime_DayOfWeek",  "ScanTime_DayName",  "ScanTime_HourOfDay",  "AssociatedTo")----------------------------------------------------------- LEFT JOIN matrix and analytic results---------------------------------------------------------select    join_matrix."HsysName"                              AS "HsysName",    join_matrix."FacilityName"                          AS "FacilityName",    join_matrix."ScanTime_Date"                         AS "ScanTime_Date",    join_matrix."ScanTime_DayOfWeek"                    AS "ScanTime_DayOfWeek",    join_matrix."ScanTime_DayName"                      AS "ScanTime_DayName",    join_matrix."ScanTime_HourOfDay"                    AS "ScanTime_HourOfDay",    join_matrix."AssociatedTo"                          AS "AssociatedTo",    coalesce(analytic_scan_data_final."AvgInstFlow",0)  AS "AvgInstFlow",    coalesce(analytic_scan_data_final."AvgTrayFlow",0)  AS "AvgTrayFlow"     from join_matrixleft join analytic_scan_data_final        on (analytic_scan_data_final."FacilityName"       =  join_matrix."FacilityName"       and  analytic_scan_data_final."ScanTime_Date"      =  join_matrix."ScanTime_Date"       and  analytic_scan_data_final."ScanTime_HourOfDay" =  join_matrix."ScanTime_HourOfDay"       and  analytic_scan_data_final."AssociatedTo"       =  join_matrix."AssociatedTo");ALTER VIEW api.decon_demand_flow    OWNER TO user_change_structure;-------------------------------------------------- Register view------------------------------------------------CALL view_register ('api','decon_demand_flow','Average demand by hour for the past eight weeks.','PROD Decon Demand Flow PG');