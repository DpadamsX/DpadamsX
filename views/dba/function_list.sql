DROP VIEW IF EXISTS dba.function_list;CREATE OR REPLACE VIEW dba.function_list ASSELECT	n.nspname AS SCHEMA,	P.proname AS function_name,	P.proargtypes,	p.oid AS function_oid,	l.lanname AS lang,	typ.typname AS return_type,	CASE WHEN (P.prosecdef = TRUE) THEN 'INVOKER' ELSE 'OWNER' END AS run_as,	pg_get_userbyid (P.proowner) AS owner_name,	P.proisstrict AS STRICT,	P.proretset AS returnset,	P.provolatile AS VOLATILE,	P.proargnames AS paramnames,	pg_get_expr (P.proargdefaults, 'pg_proc' :: regclass) AS defaultvalues,	P.proconfig AS configparams,	P.proallargtypes AS paramalltypes,	obj_description (P.oid) AS COMMENT,	(P.oid <= d.datlastsysoid) AS systable,	typns.nspname AS rettypeschema,	P.proargmodes AS parammodes,	P.procost AS estimcost,	P.prorows AS estimrows,	P.prosrc AS definition,	P.proacl AS aclFROM	pg_proc P	LEFT JOIN pg_type typ ON typ.oid = P.prorettype	LEFT JOIN pg_namespace typns ON typns.oid = typ.typnamespace	LEFT JOIN pg_namespace n ON n.oid = P.pronamespace	LEFT JOIN pg_language l ON l.oid = P.prolang	LEFT JOIN pg_user u ON P.proowner = u.usesysid	LEFT JOIN pg_database d ON d.datname = current_database ()WHERE	has_function_privilege(P.oid,'execute') AND	n.nspname NOT IN ('information_schema','pg_catalog')ORDER BY	n.nspname,	P.proname;ALTER VIEW dba.function_list	OWNER TO user_change_structure;-------------------------------------------------- Register view------------------------------------------------CALL view_register ('dba','function_list','Lists all of our functions, with a lot of under-the-hood details.');