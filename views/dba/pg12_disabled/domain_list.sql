DROP VIEW IF EXISTS dba.domain_list;CREATE OR REPLACE VIEW dba.domain_list ASselect pg_type.oid,       typnamespace::regnamespace as schema_name,       typname as domain_name,       typbasetype::regtype as base_type_name,   -- These aren't all possible...but I'm not sure which ones *are* possible here. So, I've put them all in.       case when typcategory = 'A' then 'Array'            when typcategory = 'B' then 'Boolean'            when typcategory = 'C' then 'Composite'            when typcategory = 'D' then 'Date/time'            when typcategory = 'E' then 'Enum'            when typcategory = 'G' then 'Geometric'            when typcategory = 'I' then 'Network address'            when typcategory = 'N' then 'Numeric'            when typcategory = 'P' then 'Pseudo-types'            when typcategory = 'R' then 'Range'            when typcategory = 'S' then 'String'            when typcategory = 'T' then 'Timespan'            when typcategory = 'U' then 'User-defined'            when typcategory = 'V' then 'Bit-string'            when typcategory = 'X' then 'Unknown'        end as type_category,        pg_constraint.conname AS constraint_name,       case when contype = 'c' then 'check'            when contype = 'f' then 'foreign key'            when contype = 'p' then 'primary key'            when contype = 'u' then 'unique'            when contype = 't' then 'constraint trigger'            when contype = 'x' then 'exclusion'        end as constraint_type,       typnotnull as not_null_constraint, -- pg_type.typnotnull is only used for domains. It's an attribute on the type, not a distinct rule stored in pg_constraint.	    typowner::regrole as owner_name,       pg_get_constraintdef(pg_constraint.oid) as definition/*Don't need this, we're searching for 'd'.FYI, if you have a domain named foo_bar,then there's a _foo_bar with typtype = 'b'case when typtype = 'b' then 'base'     when typtype = 'c' then 'composite'     when typtype = 'd' then 'domain'     when typtype = 'e' then 'enum'     when typtype = 'p' then 'pseudo'     when typtype = 'r' then 'range'     else 'Not a domain'end as type_type,*/             from pg_type right join pg_constraint ON (pg_constraint.contypid = pg_type.oid) -- Get only the domain definitions from our custom schemas. -- As it turns out, there are a few built in domains shown -- in information_schema too.where typtype = 'd' AND -- Just the domains     typnamespace::regnamespace::text NOT IN ('information_schema','pg_class'); -- Ignore built-in domains, I'm only after custom ones.ALTER VIEW dba.domain_list	OWNER TO user_change_structure;-------------------------------------------------- Register view------------------------------------------------CALL view_register ('dba','domain_list','Lists our custom types created with CREATE DOMAIN. (Domains are custom types with built-in rules.)');